---
title: "BDA_2024_MetaAnalysis_ViralEncephalitis"
author: "Duy Nguyen"
date: "2024-07-22"
output: 
  pdf_document:
    latex_engine: xelatex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Research Flow of Meta-Analysis of Transcriptomics Profile in Viral Encephalitis

**Step 1:** Project set up with necessary packages

**Step 2:** Search for dataset in Gemma using individual search terms, including:

- Relevant search terms

- Specific virus names with capabilities for causing encephalitis

Datasets included for meta-analysis: GSE30577, GSE42264, GSE44331, GSE51365,
GSE53784, GSE91074

**Step 3:** Assess gene expression range 

Some datasets, especially Agilent microarray datasets, were normalized incorrectly,
which may require re-normalization.

**Step 4:** Extract statistical contrasts of differential analysis in the datasets

These statistical contrasts allow us to check if the differential analyses are:

- Subsetted by brain region 

- Included unwanted subjects

- Set up in an appropriate manner with the reference group

Based on the statistical contrasts, we might need to re-run the differential analysis

**Step 5:** Download the differential expression (DE) results from each dataset 

**Step 6:** Filter DE results for rows with good gene annotation

**Step 7:** Extract DE results for the contrasts of interest

**Step 8:** Collapse DE results to one result per gene & Calculate standard error
and sampling variance

Gene expression can be measured using multiple probes (microarray). Therefore,
DE results need to be collapsed to one result per gene.

Standard error of Log2FC = Log2FC/T-statistics

Sampling variance = Average of standard error of each gene^2

**Step 9:** Align DE results from same models (either from mouse model or rat model)

As DE results from different datasets are in slightly different orders due to 
various experimental factors, we want to align these results so that the DE results 
from each dataset are columns, with each row representing a different gene.

**Step 10:** Align DE results from different models (combine DE results from both 
mouse model and rat model using the ortholog database from Jackson Lab)

**Step 11:** Compare Log2FC across datasets with correlation matrix and hierarchically 
clustered heatmap

**Step 12:** Meta-analysis with random effect models

Meta-analysis is performed using effect sizes (Log2FC) and sampling variances (SV)

**Step 13:** Correct p-value for each gene using Benjamini-Hochberg method for 
False Discovery Rate (FDR or q-value)

**Step 14:** Create forest plots for statistically significant genes 


### 1) Project Set Up

```{r setdw, eval = FALSE, echo = FALSE}
# Set working directory 
setdw("/Users/manhduynguyen/BDA_2024_ViralEncephalitis")
```


```{r renv, eval = FALSE, echo = FALSE}
# Initiate the project with renv
renv::init()

# Save to lockfile
renv::snapshot()
```


```{r install_pack, eval = FALSE, echo = FALSE}
# Download packages
if(!requireNamespace("devtools", quietly = T)){
  install.packages("devtools")
}
devtools:: install_github("PavlidisLab/gemma.R", force = T)

if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install("multtest")                                 

install.packages("plyr")
install.packages("metafor")
install.packages("tidyverse")
install.packages("writexl")
install.packages("pheatmap")
install.packages("RColorBrewer")
install.packages("viridis")
```


```{r load_pack}
# Load packages
library("gemma.R")
library("plyr")
library("metafor")
library("tidyverse")
library("writexl")
library("pheatmap")
library("RColorBrewer")
library("viridis")
library("multtest")

# Check loaded packages 
(.packages())
```


### 2) Gemma Dataset Search

```{r data_search, eval = FALSE}
# Extract datasets from Gemma based on single search terms
Sepsis <- searchDatasets("Sepsis", limit = 100)
Encephalitis <- searchDatasets("Encephalitis", limit = 100)
Viral_Encephalitis <- searchDatasets("Viral Encephalitis", limit = 100)
Neuroinflammation <- searchDatasets("Neuroinflammation", limit = 100)
Neuroimmune <- searchDatasets("Neuroinmmune", limit = 100)
Neuroimmunology <- searchDatasets("Neuroinmmunology", limit = 100)
Neurotoxicity <- searchDatasets("Neurotoxicity", limit = 100)
Neuroimmunity <- searchDatasets("Neuroimmunity", limit = 100)
Neuroinflame <- searchDatasets("Neuroinflame", limit = 100)
Neuroinflammatory <- searchDatasets("Neuroinflammatory", limit = 100)
Neurotropic <- searchDatasets("Neurotropic", limit = 100)
Neuroinvasive <- searchDatasets("Neuroinvasive", limit = 100)
Neurovirulence <- searchDatasets("Neurovirulence", limit = 100)
Viral = <- searchDatasets("Viral", limit = 100)
Virus = <- searchDatasets("Virus", limit = 100)
Infection <- searchDatasets("Infection", limit = 100)
Viral_Infection <- searchDatasets("Viral Infection", limit = 100)
Brain_Infection <- searchDatasets("Brain Infection", limit = 100)
Brain_Inflammation <- searchDatasets("Brain Inflammation", limit = 100)
Brain_Immunology <- searchDatasets("Brain Immunology", limit = 100)
Brain_Inflammatory <- searchDatasets("Brain Inflammatory", limit = 100)

# Extract datasets from Gemma based on specific viruses
Zika <- searchDatasets("Zika", limit = 100)
Chikungunya <- searchDatasets("Chikungunya", limit = 100)
West_Nile <- searchDatasets("West Nile", limit = 100)
Japanese_encephalitis <- searchDatasets("Japanese encephalitis", limit = 100)
Venezuelan_encephalitis <- searchDatasets("Venezuelan encephalitis", limit = 100)
StLouis_encephalitis <- searchDatasets("St Louis encephalitis", limit = 100)
Polio <- searchDatasets("Polio", limit = 100)
Mumps <- searchDatasets("Mumps", limit = 100)
Measles <- searchDatasets("Measles", limit = 100)
Nipah <- searchDatasets("Nipah", limit = 100)
Hendra <- searchDatasets("Hendra", limit = 100)
Herpes <- searchDatasets("Herpes", limit = 100)
Varicella <- searchDatasets("Varicella zoster", limit = 100)
Epstein_Barr <- searchDatasets("Epstein Barr", limit = 100)
Cytomegalo <- searchDatasets("Cytomegalovirus", limit = 100)
Rabies <- searchDatasets("Rabies", limit = 100)
Influenza <- searchDatasets("Influenza", limit = 100)
Corona <- searchDatasets("Coronavirus", limit = 100)
Yellow_fever <- searchDatasets("Yellow fever", limit = 100)



# Extract the data to excel file
write_xlsx(Sepsis, "Sepsis.xlsx") 
write_xlsx(Encephalitis,"Encephalitis.xlsx")
write_xlsx(Viral_Encephalitis, "Viral Encephalitis.xlsx")
write_xlsx(Neuroinflammation, "Neuroinflammation.xlsx")
write_xlsx(Neuroimmunity,"Neuroimmunity.xlsx")
write_xlsx(Neuroinflammatory,"Neuroinflammatory.xlsx")
write_xlsx(Neurotoxicity,"Neurotoxicity.xlsx")
write_xlsx(Neurotropic,"Neurotropic.xlsx")
write_xlsx(Neuroinvasive, "Neuroinvasive.xlsx")
write_xlsx(Neurovirulence, "Neurovirulence")
write_xlsx(Viral, "Viral.xlsx")
write_xlsx(Viral_Infection,"Viral Infection.xlsx")
write_xlsx(Virus,"Virus.xlsx")
write_xlsx(Infection, "Infection.xlsx")

# Count the frequency of unique values in a dataframe
table(Sepsis$taxon.Name) #Count based on the model (human, mouse, rat)

# Combine and exclude datasets of other models than mouse/rat
Total_datasets = rbind(Brain_Immunology, Brain_Infection, Brain_Inflammation, 
                       Corona, Cytomegalo, Encephalitis, Epstein_Barr, Hendra, 
                       Herpes, Infection,Influenza,Japanese_encephalitis, Measles, 
                       Neuroinflammation, Neuroinflammatory, Neuroinvasive, 
                       Neurotoxicity, Neurotropic, Neurovirulence, Rabies, Sepsis, 
                       Varicella, Venezuelan_encephalitis, Viral, Viral_Encephalitis, 
                       Viral_Infection, Virus, West_Nile, Yellow_fever, Zika)
Total_datasets_eli_1 = subset(Total_datasets, Total_datasets$taxon.Name == "mouse")
Total_datasets_eli_2 = subset(Total_datasets, Total_datasets$taxon.Name == "rat")
Total_datasets_eli = unique(rbind(Total_datasets_eli_1, Total_datasets_eli_2))
write_xlsx(Total_datasets_eli, "Total datasets.xlsx")
```

Through process of inclusion/exclusion criteria, 6 datasets are included in the 
meta-analysis, including: GSE30577, GSE42264, GSE44331, GSE51365, GSE53784,
GSE91074.


### 3) Gene Expression Range Assessment

```{r func_check_gene_express}
# Create a function to check the expression range of the dataset 
# (especially for the Agilent microarray datasets)
CheckGeneExpressionRange <- function(dataset_shortname){
  
  # Retrieve the processed expression data for the given dataset
  expression_data <- get_dataset_processed_expression(dataset_shortname)
  
  # Print the structure of the expression data
  print(str(expression_data))
  
  # The first four columns are row metadata: Probe, GeneSymbol, GeneName, NCBI ID
  # The rest of the columns are gene expression values for each subject
  
  # Exclude metadata row (row 1-4) and convert the gene expression columns to a 
  # matrix for further analysis 
  expression_matrix <- as.matrix(expression_data[,-1:-4])
  
  # Create a histogram of the expression data 
  hist(expression_matrix, 
       main = paste("Histogram of Expression Data for", dataset_shortname),
       # The y-axis is the gene frequency
       # The x-axis is log 2 gene expression - log 2 counts per million
       xlab = "Log 2 Expression", ylab = "Frequency")
  
       # The large spike on the left side of the histogram ("floor effect") are 
       # all of the genes that are not truly expressed or have too low of expression 
       # to be measurable 
  
  # Log 2 RNA-seq dataset has the range between -5 to 12
  # Log 2 Microarray dataset has the range between 4 to 15
  
  # Calculate the min, median, max values of the expression data
  min_val <- min(expression_matrix)
  median_val <- median(expression_matrix)
  max_val <- max(expression_matrix)
  
  # Print the calculated values
  print(paste("Minimum value:", min_val))
  print(paste("Median value:", median_val))
  print(paste("Maximum value:", max_val))
}
```


```{r run_check_gene_express, cache = TRUE}
# Function use 
CheckGeneExpressionRange("GSE30577") # Min: -4.8 | Max: 8.6 | Agilent Microarray 
CheckGeneExpressionRange("GSE42264") # Min: 2.4 | Max: 14.6 | Affymetrix Array
CheckGeneExpressionRange("GSE44331") # Min: 2.9 | Max: 14.5 | Affymetrix Array
CheckGeneExpressionRange("GSE51365") # Min: 1.2 | Max: 15.7 | Affymetrix Array
CheckGeneExpressionRange("GSE53784") # Min: 2.0 | Max: 14.1 | Affymetrix Array
CheckGeneExpressionRange("GSE91074") # Min: 2.8 | Max: 14.3 | Affymetrix Array
```

Gene expression of all 6 datasets seem to be within normal range and have appropriate
distribution.


### 4) Extraction of Statistical Contrasts of Differential Analysis in Each Dataset

For the meta-analysis, we will be extracting the differential expression results 
from Gemma. The differential expression results for each dataset may include 
multiple result sets (e.g., one result set for the subset of the data from the 
hippocampus, one result set for frontal cortex). Each of these result sets may 
have multiple statistical contrasts (e.g., drug1 vs. vehicle, drug2 vs. vehicle). 
Therefore, each of the statistical contrasts is labeled with a result ID and 
contrast ID within the Gemma database. We will need to know which of these IDs 
are relevant to our project goals to easily extract their results.

We will also need to double-check that these statistical contrasts are set up in 
a manner that makes sense for our experiments:

1. For experiments that include more than one brain region, we will need to 
double-check that the results have been subsetted by brain region (instead of 
including brain region ("OrganismPart") as a factor in the model). If they have 
not been subsetted by region, we will probably need to re-run the differential 
expression analysis.

2. Depending on the goals of the meta-analysis, we may also need to re-run the 
differential expression analysis to remove other unwanted subjects (e.g., removing 
subjects with genotypes that might interfere with our results).

3. We will need to double-check that the comparisons include an appropriate 
reference group - sometimes they are reversed in Gemma (e.g., having the drug 
treatment set as the baseline, with vehicle as the manipulation). If this is the 
case, we will need to invert the effects when we input them into our meta-analysis 
(multiply the effects by -1).


```{r func_contrast_extract}
# Create a function to extract statistical contrasts of differential analysis 
# in each dataset 
GettingResultSetInfoForDatasets <- function(ExperimentIDs) {
  
  # Create a dataframe to store the results 
  resultsets_toscreen <- data.frame(
    ExperimentIDs = character(),
    ResultSetIDs = character(),
    ContrastIDs = character(),
    FactorCategory = character(),
    ExperimentalFactors = character(),
    BaselineFactors = character(),
    Subsetted = logical(),
    SubsetBy = character(),
    stringsAsFactors = FALSE
  )
  
  # Loop through each of the datasets 
  for (i in c(1:length(ExperimentIDs))) {
    
    # Extract the differential expression analysis from the datasets 
    design <- get_dataset_differential_expression_analyses(ExperimentIDs[i])
    
    # Check if the design dataframe has rows
    if (nrow(design) > 0) {
      
      # Create the vectors to store the experimental and baseline factors
      experimental_factors <- vector(mode = "character", length = nrow(design))
      baseline_factors <- vector(mode = "character", length = nrow(design))
      
      # Loop through each result.ID in the design dataframe
      for (j in c(1:nrow(design))) {
        
        # Concatenate the experimental factors into a single string
        experimental_factors[j] <- paste(design$experimental.factors[[j]]$summary, 
                                         collapse = ";")
        
        # Concatenate the baseline factors into a single string 
        baseline_factors[j] <- paste(design$baseline.factors[[j]]$summary, 
                                     collapse = ";")
      }
      
      # Create a vector to store subset information
      SubsetBy <- vector(mode = "character", length = nrow(design))
      
      # Check if the design dataframe is subsetted or not
      if (design$isSubset[1] == TRUE) {
        
        # Loop through each result.ID to extract and concatenate subset information
        for (j in c(1:nrow(design))) {
          SubsetBy[j] <- paste(design$subsetFactor[[j]]$summary, collapse = ";")
        } 
      } else {
        # If not subsetted, fill the SubsetBy vector with NA values 
        SubsetBy <- rep(NA, length(design$result.ID))
      }
      
      # Create a temporary dataframe to store extracted info
      resultsets_for_experiment <- data.frame(
        ExperimentIDs = ExperimentIDs[i],
        ResultSetIDs = design$result.ID,
        ContrastIDs = design$contrast.ID,
        FactorCategory = design$factor.category,
        ExperimentalFactors = experimental_factors,
        BaselineFactors = baseline_factors,
        Subsetted = design$isSubset,
        SubsetBy = SubsetBy,
        stringsAsFactors = FALSE
      )
      
      # Append the temporary dataframe with the dataframe created initially
      resultsets_toscreen <- rbind(resultsets_toscreen, resultsets_for_experiment)
      
    }
  }
  
  # Add empty columns to store screening notes 
  resultsets_toscreen <- cbind(
    resultsets_toscreen,
    Include = vector(mode = "character", length = nrow(resultsets_toscreen)),
    WrongBaseline = vector(mode = "character", length = nrow(resultsets_toscreen)),
    ResultsNotRegionSpecific = vector(mode = "character", length = nrow(resultsets_toscreen)),
    ReAnalyze = vector(mode = "character", length = nrow(resultsets_toscreen)),
    stringsAsFactors = FALSE
  )
  
  # Export the final dataframe into the working directory
  write.csv(resultsets_toscreen, "ResultSets_toScreen.csv")
  
  # Print a message to indicate that the results have been saved 
  print("Output object: ResultSets_toScreen.csv")
}
```


```{r run_contrast_extract}
# Set up a vector of the names of all datasets
ExperimentIDs <- c("GSE30577", "GSE42264", "GSE44331", 
                   "GSE51365", "GSE53784","GSE91074")

# Function use
GettingResultSetInfoForDatasets(ExperimentIDs)
```


### 5) Downloading the DE Results from Each Dataset

```{r func_download_DEResults}
# Create a function to download DE results and extract Log2FC and T-statistics 
# for contrasts of interest 
DownloadingDEResults <- function(ResultSets_contrasts){
  
  # Identify the unique ResultSet IDs
  # Some ResultSets may have multiple statistical contrasts, but we only want unique ResultSet IDs
  UniqueResultSetIDs <- unique(ResultSets_contrasts$ResultSetIDs) 
  
  # Print the identified unique ResultSet IDs
  print("ResultSets identified as being of interest")
  print(UniqueResultSetIDs)
  
  # Download DE results for each unique ResultSet ID
  differentials <- UniqueResultSetIDs %>%
    # The function returns a list because single experiment may have multiple 
    # resultSets
    # Only take the first element of the output
    # The "resultSet" argument is used to directly access the results we need
    lapply(function(x) {get_differential_expression_values(resultSets = x)[[1]]})
  
  # Some datasets might not have all the advertised DE results due to a variety of
  # so we need to remove empty differential (only keep differential with rows present)
  non_missing_contrasts <- sapply(differentials, function(df) nrow(df) > 0)
  
  # Return the "differentials" object that contains the DE results of contrast of interest
  differentials <<- differentials[non_missing_contrasts] 
  UniqueResultSetIDs <<- UniqueResultSetIDs[non_missing_contrasts]
  
  # Print the ResultSet IDs that had DE results
  print("ResultSets that had DE results:")
  print(UniqueResultSetIDs)
  
  # Print a message to inform the structure of the output "differentials"
  print("Your DE results for each of the ResultSets are stored in object differentials.")
  print("This object is structured as a list of dataframes.")
  print("Each element in the list represents a ResultSet, with the dataframe containing DE results")
  
  # Extract the effect sizes of Log2FC of contrasts of interest
  print("Columns of effect sizes (Log2FC) for contrasts of interest:")
  Contrasts_Log2FC <- paste("contrast_", ResultSets_contrasts$ContrastIDs, 
                             "_log2fc", sep = "")
  print(Contrasts_Log2FC)
  
  # Extract the T-statistics of contrasts of interest for calculating sampling variances
  print("Columns of T-statistics for contrasts of interest:")
  Contrasts_Tstat <- paste("contrast_", ResultSets_contrasts$ContrastIDs,
                            "_tstat", sep = "")
  print(Contrasts_Tstat)
  
  # Remove the temporary Log2FC and T-statistics of contrast of interest
  rm(Contrasts_Log2FC, Contrasts_Tstat)
}
```


```{r run_download_DEResults, cache = TRUE}
# Import the CSV file with contrasts of interest
ResultSets_contrasts <- read.csv("ResultSets_Screened.csv", 
                                 header = TRUE, stringsAsFactors = FALSE)
# Function use
DownloadingDEResults(ResultSets_contrasts)

# Check the structure of the "differentials" object
str(differentials)
```


```{r func_save_DEResults}
# Create a function to save DE results for each ResultSet
SavingGemmaDEResults_forEachResultSet <- function(differentials, 
                                                  UniqueResultSetIDs, 
                                                  ResultSets_contrasts){
    
  # Loop through each dataset (list element) in "differentials" object
  for (i in c(1:length(differentials))){
    
    # Get the current ResultSet ID
    ThisResultSet <- UniqueResultSetIDs[i]
    
    # Get the dataset ID corresponding to the current ResultSet ID
    # Some datasets have multiple ResultSets, so take the dataset ID from the 
    # first matching entry
    ThisDataSet <- ResultSets_contrasts$ExperimentID[ResultSets_contrasts$ResultSetIDs == ThisResultSet][1] 
    
    # Export the DE results for the current ResultSet ID into the working directory
    write.csv(differentials[[i]], paste("DEResults_", ThisDataSet, "_", ThisResultSet, ".csv", sep=""))
    
    # Remove the temporary IDs
    rm(ThisDataSet, ThisResultSet)
   }
  
  # Print a message to indicate the DE results have been exported into working directory
  print("Output object: DEResults_Dataset ID_ResultSet ID")
}
```


```{r run_save_DEResults, cache = TRUE}
# Function use
SavingGemmaDEResults_forEachResultSet(differentials, 
                                      UniqueResultSetIDs,
                                      ResultSets_contrasts)
```


### 6) Filter of DE results for rows with good gene annotation

```{r func_gene_filter}
# Create a function to filter for rows with good gene annotation 
FilteringDEResults_GoodAnnotation <- function(DE_Results){
  
  # Print the total number of rows in the DE results
  print("# of rows in results")
  print(nrow(DE_Results))
  
  # Print the number of rows with missing NCBI annotation
  print("# of rows with missing NCBI annotation:")
  print(sum(DE_Results$NCBIid == "" | DE_Results$NCBIid == "null", na.rm = TRUE))
  
  # Print the number of rows with NA NCBI annotation
  print("# of rows with NA NCBI annotation:")
  print(sum(is.na(DE_Results$NCBIid)))
  
  # Print the number of rows with missing Gene Symbol annotation
  print("# of rows with missing Gene Symbol annotation:")
  print(sum(DE_Results$GeneSymbol == ""| DE_Results$GeneSymbol == "null", na.rm = TRUE))
  
  # Print the number of rows mapped to multiple NCBI IDs
  print("# of rows mapped to multiple NCBI IDs:")
  print(length(grep('\\|', DE_Results$NCBIid)))
  
  # Print the number of rows mapped to multiple Gene Symbols
  print("# of rows mapped to multiple Gene Symbols:")
  print(length(grep('\\|', DE_Results$GeneSymbol)))
  
  # Subset data containing rows with valid NCBI EntrezID (non-empty and non-null)
  DE_Results_NoNA <- DE_Results[(DE_Results$NCBIid == "" | 
                                 DE_Results$NCBIid == "null") == FALSE & 
                                 is.na(DE_Results$NCBIid) == FALSE,]
  
  # Subset data annotated with a single gene (not ambiguously mapped to more 
  # than one gene)
  if(length(grep('\\|', DE_Results_NoNA$NCBIid)) == 0){
    # If there are no rows with multiple NCBI IDs, use the current subset
    DE_Results_GoodAnnotation <- DE_Results_NoNA
  } else {
    # Extract only rows annotated with a single Gene Symbol (no pipe character '|')
    DE_Results_GoodAnnotation <- DE_Results_NoNA[-(grep('\\|', DE_Results_NoNA$NCBIid)),]
  }

  # Print the number of rows with good annotation
  print("# of rows with good annotation")
  print(nrow(DE_Results_GoodAnnotation))
  
  # Get the name of the input object as a string for file naming
  ID <- deparse(substitute(DE_Results))
  
  # Export the DE results with good annotations into the working directory
  write.csv(DE_Results_GoodAnnotation, paste(ID, "_GoodAnnotation.csv", sep = ""))
  
  # Remove the temporary DE result objects
  rm(DE_Results_NoNA, DE_Results)
  
  # Print a message to the DE results with good annotations have been exported 
  # into working directory 
  print(paste("Output object:", ID, "_GoodAnnotation.csv", sep = ""))
  
  # Return the DE results with good annotation into the environment
  return(DE_Results_GoodAnnotation)
}
```


```{r run_gene_filter, cache = TRUE}
# Separate the DE results from object "differentials"
DEResults_GSE30577 <- differentials[[1]]
DEResults_GSE42264 <- differentials[[2]]
DEResults_GSE44331 <- differentials[[3]]
DEResults_GSE51365 <- differentials[[4]]
DEResults_GSE53784 <- differentials[[5]]
DEResults_GSE91074 <- differentials[[6]]

# Function use
DE_Results_GSE30577_GoodAnnotation <- FilteringDEResults_GoodAnnotation(DEResults_GSE30577)
DE_Results_GSE42264_GoodAnnotation <- FilteringDEResults_GoodAnnotation(DEResults_GSE42264)
DE_Results_GSE44331_GoodAnnotation <- FilteringDEResults_GoodAnnotation(DEResults_GSE44331)
DE_Results_GSE51365_GoodAnnotation <- FilteringDEResults_GoodAnnotation(DEResults_GSE51365)
DE_Results_GSE53784_GoodAnnotation <- FilteringDEResults_GoodAnnotation(DEResults_GSE53784)
DE_Results_GSE91074_GoodAnnotation <- FilteringDEResults_GoodAnnotation(DEResults_GSE91074)

# Check the structure of the DE results with good annotations 
# str(DE_Results_GSE30577_GoodAnnotation)
# str(DE_Results_GSE42264_GoodAnnotation)
# str(DE_Results_GSE44331_GoodAnnotation)
# str(DE_Results_GSE51365_GoodAnnotation)
# str(DE_Results_GSE53784_GoodAnnotation)
# str(DE_Results_GSE91074_GoodAnnotation)
```


### 7) Extraction of DE results for the contrasts of interest

```{r func_extract_contrastID}
# Create a function to extract the contrast ID from FC column names 
GetContrastIDsforResultSet <- function(NamesOfFoldChangeColumns){
  
  # Split the column names using the underscore as a delimiter
  # The result is a list where each element is a vector of the split parts of 
  # each column name
  ColumnNames_BrokenUp <- strsplit(NamesOfFoldChangeColumns, "_")
  
  # Convert the list of split names to a matrix
  MatrixOfColumnNames_BrokenUp <- do.call(rbind, ColumnNames_BrokenUp)
  
  # Extract the contrast IDs in the second column
  ContrastIDs_inCurrentDF <- MatrixOfColumnNames_BrokenUp[, 2]
  
  # Return the extracted contrast ID
  return(ContrastIDs_inCurrentDF)
}
```


```{r func_extract_contrast_DEResults}
# Create a function to extract DE results for contrasts of interest
ExtractingDEResultsForContrasts <- function(DE_Results_GoodAnnotation, 
                                            Contrasts_Log2FC, 
                                            Contrasts_Tstat, 
                                            ResultSet_contrasts){
  
    # Print the column names in the DE results with good annotations for the 
    # current ResultSet
    print("Columns in the DE results for the current ResultSet:")
    print(colnames(DE_Results_GoodAnnotation))
  
    # Print the column names that correspond to Log2FC values for contrasts of interest
    print("Columns of Log2FC for contrasts of interest within the DE results for the current ResultSet:")
    NamesOfFoldChangeColumns <- colnames(DE_Results_GoodAnnotation)[colnames(DE_Results_GoodAnnotation) %in% Contrasts_Log2FC]
    print(NamesOfFoldChangeColumns)
  
    # Print the column names that correspond to T-statistics values for contrasts of interest
    print("Columns of T-statistics for contrasts of interest within the DE results for the current ResultSet:")
    NamesOfTstatColumns <- colnames(DE_Results_GoodAnnotation)[colnames(DE_Results_GoodAnnotation) %in% Contrasts_Tstat]
    print(NamesOfTstatColumns)
  
    # Extract contrast IDs from FC column names using the function "GetContrastIDsforResultSet"
    ContrastIDs_inCurrentDF <- GetContrastIDsforResultSet(NamesOfFoldChangeColumns)
    print("Contrast IDs for contrasts of interest within the current ResultSet:")
    print(ContrastIDs_inCurrentDF)
  
    # Extract dataset IDs for contrasts of interest
    DatasetIDs <- ResultSet_contrasts$ExperimentID[ResultSet_contrasts$ContrastIDs %in% ContrastIDs_inCurrentDF]
    print("Dataset ID for the ResultSet and contrasts:")
    print(DatasetIDs)
  
    # Extract experimental factors for contrasts of interest
    Factors_inCurrentDF <- ResultSet_contrasts$ExperimentalFactors[ResultSet_contrasts$ContrastIDs %in% ContrastIDs_inCurrentDF]
    print("Experimental factors for ResultSet and contrasts:")
    print(Factors_inCurrentDF)
  
    # Combine dataset IDs and experimental factors to create unique identifiers 
    # for each statistical comparison
    ComparisonsOfInterest <- paste(DatasetIDs, Factors_inCurrentDF, sep = "_")
    print("Current names of contrasts of interest")
    print(ComparisonsOfInterest)
  
    # Create a list to store extracted DE results and relevant metadata
    DE_result_contrast <- list(
      All_Columns = colnames(DE_Results_GoodAnnotation),
      NamesOfFoldChangeColumns = NamesOfFoldChangeColumns,
      NamesOfTstatColumns = NamesOfTstatColumns,
      Contrast_ID = ContrastIDs_inCurrentDF,
      Dataset_ID = DatasetIDs,
      Experimental_Factor = Factors_inCurrentDF,
      ComparisonsOfInterest = ComparisonsOfInterest
  )
    # Return the list of all extracted info
    return(DE_result_contrast)
}
```


```{r func_extract_contrast_stat}
# Create a function to extract the Log2FC and T-statistics of contrast of interest
GetContrastStatColumns <- function(ResultSets_contrasts){
  
  # Extract the effect sizes (Log2FC) of contrasts of interest
  Contrasts_Log2FC <- paste("contrast_", ResultSets_contrasts$ContrastIDs, "_log2fc", sep = "")

  # Extract the T-statistics of contrasts of interest for calculating sampling variances
  Contrasts_Tstat <- paste("contrast_", ResultSets_contrasts$ContrastIDs, "_tstat", sep = "")

  # Create a dataframe to store the extracted information
  Contrasts_Stat <- data.frame(
    ExperimentID = ResultSets_contrasts$ExperimentIDs,
    ContrastID = ResultSets_contrasts$ContrastIDs,
    Log2FC_Column = Contrasts_Log2FC,
    Tstat_Column = Contrasts_Tstat,
    stringsAsFactors = FALSE
  )
  
  # Return the resulting dataframe
  return(Contrasts_Stat)
}
```


```{r run_extract_contrast_stat, cache = TRUE}
# Function use
Contrasts_Stat_Columns <- GetContrastStatColumns(ResultSets_contrasts)
```


```{r prep_contrast_stat, cache = TRUE}
# Prepare "Contrast_Log2FC" and "Contrast_Tstat" arguments for extracting DE results 
# of contrasts of interest

# GSE30577
Contrasts_Log2FC_GSE30577 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE30577") %>%
  pull(Log2FC_Column)

Contrasts_Tstat_GSE30577 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE30577") %>%
  pull(Tstat_Column)

# GSE42264 
Contrasts_Log2FC_GSE42264 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE42264") %>%
  pull(Log2FC_Column)

Contrasts_Tstat_GSE42264 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE42264") %>%
  pull(Tstat_Column)

# GSE44331
Contrasts_Log2FC_GSE44331 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE44331") %>%
  pull(Log2FC_Column)

Contrasts_Tstat_GSE44331 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE44331") %>%
  pull(Tstat_Column)

# GSE51365
Contrasts_Log2FC_GSE51365 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE51365") %>%
  pull(Log2FC_Column)

Contrasts_Tstat_GSE51365 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE51365") %>%
  pull(Tstat_Column)

# GSE53784
Contrasts_Log2FC_GSE53784 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE53784") %>%
  pull(Log2FC_Column)

Contrasts_Tstat_GSE53784 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE53784") %>%
  pull(Tstat_Column)

# GSE91074
Contrasts_Log2FC_GSE91074 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE91074") %>%
  pull(Log2FC_Column)

Contrasts_Tstat_GSE91074 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE91074") %>%
  pull(Tstat_Column)
```


```{r run_extract_contrast_DEResults, cache = TRUE}
# Function use

# GSE30577
DE_Results_Contrasts_GSE30577 <- ExtractingDEResultsForContrasts(DE_Results_GSE30577_GoodAnnotation,
                                                                 Contrasts_Log2FC_GSE30577,
                                                                 Contrasts_Tstat_GSE30577,
                                                                 ResultSets_contrasts)

# GSE42264
DE_Results_Contrasts_GSE42264 <- ExtractingDEResultsForContrasts(DE_Results_GSE42264_GoodAnnotation,
                                                                 Contrasts_Log2FC_GSE42264,
                                                                 Contrasts_Tstat_GSE42264,
                                                                 ResultSets_contrasts)

# GSE44331
DE_Results_Contrasts_GSE44331 <- ExtractingDEResultsForContrasts(DE_Results_GSE44331_GoodAnnotation,
                                                                 Contrasts_Log2FC_GSE44331,
                                                                 Contrasts_Tstat_GSE44331,
                                                                 ResultSets_contrasts)

# GSE51365
DE_Results_Contrasts_GSE51365 <- ExtractingDEResultsForContrasts(DE_Results_GSE51365_GoodAnnotation,
                                                                 Contrasts_Log2FC_GSE51365,
                                                                 Contrasts_Tstat_GSE51365,
                                                                 ResultSets_contrasts)

# GSE53784
DE_Results_Contrasts_GSE53784 <- ExtractingDEResultsForContrasts(DE_Results_GSE53784_GoodAnnotation,
                                                                 Contrasts_Log2FC_GSE53784,
                                                                 Contrasts_Tstat_GSE53784,
                                                                 ResultSets_contrasts)

# GSE91074
DE_Results_Contrasts_GSE91074 <- ExtractingDEResultsForContrasts(DE_Results_GSE91074_GoodAnnotation,
                                                                 Contrasts_Log2FC_GSE91074,
                                                                 Contrasts_Tstat_GSE91074,
                                                                 ResultSets_contrasts)
```


### 8) Collapse of DE results to one result per gene & Calculation of standard error
### and sampling variance

Gene expression can be measured using multiple probes (microarray). Therefore,
DE results need to be collapsed to one result per gene.

Standard error of Log2FC = Log2FC/T-statistics

Sampling variance = Average of standard error of each gene^2 


```{r func_collapse_contrast_DEResults}
CollapsingDEResults_OneResultPerGene<-function(GSE_ID, 
                                               DE_Results_GoodAnnotation, 
                                               ComparisonsOfInterest, 
                                               NamesOfFoldChangeColumns, 
                                               NamesOfTstatColumns){
  
  # Print a message to check if the vectors containing FC and T-stat column names 
  # are in the same order as the comparisons of interest
  print("Check if the vectors containing FC and Tstat column names contain the same order as the comparison of interest")
  
  # Print the number of unique NCBI IDs in the DE results
  print("# of rows with unique NCBI IDs:")
  print(length(unique(DE_Results_GoodAnnotation$NCBIid)))
  
  # Print the number of unique Gene Symbols in the DE results
  print("# of rows with unique Gene Symbols:")
  print(length(unique(DE_Results_GoodAnnotation$GeneSymbol)))
  
  # Create a folder named after the dataset ID to store results
  dir.create(paste("./", "Collapsing_DEResults_", GSE_ID, sep=""))
  
  # Set the working directory to the newly created folder
  setwd(paste("./", "Collapsing_DEResults_", GSE_ID, sep=""))
  
  # Create lists to store results
  DE_Results_GoodAnnotation_FoldChange_Average <- list()
  DE_Results_GoodAnnotation_Tstat_Average <- list()
  DE_Results_GoodAnnotation_SE_Average <- list()
  
  # Loop through each column containing FC and T-statistic info for the contrasts of interest
  for(i in c(1:length(NamesOfFoldChangeColumns))){
    
    # Select the Log2FC column of interest
    FoldChangeColumn <- select(DE_Results_GoodAnnotation, NamesOfFoldChangeColumns[i])
    
    # Select the T-stat column of interest
    TstatColumn <- select(DE_Results_GoodAnnotation, NamesOfTstatColumns[i])
    
    # Calculate the standard error (SE)
    DE_Results_GoodAnnotation_SE <- FoldChangeColumn[[1]]/TstatColumn[[1]]
    
    # Calculate the average Log2FC per gene
    DE_Results_GoodAnnotation_FoldChange_Average[[i]] <- tapply(FoldChangeColumn[[1]], 
                                                                DE_Results_GoodAnnotation$NCBIid, 
                                                                mean)
    
    # Calculate the average T-statistics per gene
    DE_Results_GoodAnnotation_Tstat_Average[[i]] <- tapply(TstatColumn[[1]], 
                                                           DE_Results_GoodAnnotation$NCBIid, 
                                                           mean)
    
    # Calculate the average SE per gene
    DE_Results_GoodAnnotation_SE_Average[[i]] <- tapply(DE_Results_GoodAnnotation_SE, 
                                                        DE_Results_GoodAnnotation$NCBIid, 
                                                        mean)
    
  }
  
  # Combine averaged Log2FC values into a single dataframe 
  DE_Results_GoodAnnotation_FoldChange_AveragedByGene <- do.call(cbind, DE_Results_GoodAnnotation_FoldChange_Average)
  
  # Print the dimensions of the averaged Fold Change matrix
  print("Dimensions of Fold Change matrix, averaged by gene symbol:")
  print(dim(DE_Results_GoodAnnotation_FoldChange_AveragedByGene))
  
  # Name the columns in the dataframe to describe the contrast of interest
  colnames(DE_Results_GoodAnnotation_FoldChange_AveragedByGene) <- ComparisonsOfInterest
  
  # Export the averaged Log2FC results into the working directory
  write.csv(DE_Results_GoodAnnotation_FoldChange_AveragedByGene, 
            paste("DEResults_", GSE_ID, "_GoodAnnotation_FoldChange_AveragedByGene.csv", sep = ""))
  
  # Combine T-statistics values into a single dataframe 
  DE_Results_GoodAnnotation_Tstat_AveragedByGene<-do.call(cbind, DE_Results_GoodAnnotation_Tstat_Average)
  
  # Name the columns in the dataframe to describe the contrast of interest
  colnames(DE_Results_GoodAnnotation_Tstat_AveragedByGene) <- ComparisonsOfInterest
  
  # Export the averaged T-statistics results into the working directory
  write.csv(DE_Results_GoodAnnotation_Tstat_AveragedByGene, 
            paste("DEResults_", GSE_ID, "_GoodAnnotation_Tstat_AveragedByGene.csv", sep = ""))
  
  # Combine SE values into a single dataframe 
  DE_Results_GoodAnnotation_SE_AveragedByGene<-do.call(cbind, DE_Results_GoodAnnotation_SE_Average)
  
  # Name the columns in the dataframe to describe the contrast of interest
  colnames(DE_Results_GoodAnnotation_SE_AveragedByGene) <- ComparisonsOfInterest
  
  # Export the averaged SE results into the working directory
  write.csv(DE_Results_GoodAnnotation_SE_AveragedByGene, 
            paste("DEResults_", GSE_ID, "_GoodAnnotation_SE_AveragedByGene.csv", sep = ""))
  
  # Calculate the sampling variance (SV) by squaring the SE
  DE_Results_GoodAnnotation_SV <- (DE_Results_GoodAnnotation_SE_AveragedByGene)^2
  
  # Export the SV results into the working directory
  write.csv(DE_Results_GoodAnnotation_SV, 
            paste("DEResults_", GSE_ID, "_GoodAnnotation_SV.csv", sep = ""))
  
  # Compile all averaged results into a single list 
  TempMasterResults<-list(Log2FC = DE_Results_GoodAnnotation_FoldChange_AveragedByGene,
                          Tstat = DE_Results_GoodAnnotation_Tstat_AveragedByGene, 
                          SE = DE_Results_GoodAnnotation_SE_AveragedByGene, 
                          SV = DE_Results_GoodAnnotation_SV)
  
  # Print the name of the output
  print(paste("Output: Collapsing_DEResults", GSE_ID, sep="_"))
  
  # Clean up the environment by removing temporary results
  rm(DE_Results_GoodAnnotation, DE_Results_GoodAnnotation_SV, 
     DE_Results_GoodAnnotation_SE, DE_Results_GoodAnnotation_FoldChange_AveragedByGene,
     DE_Results_GoodAnnotation_FoldChange_Average, DE_Results_GoodAnnotation_Tstat_AveragedByGene,
     DE_Results_GoodAnnotation_Tstat_Average, DE_Results_GoodAnnotation_SE_Average, 
     FoldChangeColumn, TstatColumn, GSE_ID, ComparisonsOfInterest, NamesOfFoldChangeColumns, 
     NamesOfTstatColumns)
  
  # Set the working directory back to the parent directory
  setwd("../")
  
  # Return the compiled results
  return(TempMasterResults)
}
```


```{r prep_col_name, cache = TRUE}
# Prepare "NamesOfFoldChangeColumns" and "NamesOfTstatColumns" arguments for  
# extracting DE results of contrasts of interest

# GSE30577
NamesOfFoldChangeColumns_GSE30577 <- DE_Results_Contrasts_GSE30577[[2]]
NamesOfTstatColumns_GSE30577 <- DE_Results_Contrasts_GSE30577[[3]]
ComparisonsOfInterest_GSE30577 <- c("GSE30577_Rabies_vs_Control")

# GSE42264
NamesOfFoldChangeColumns_GSE42264 <- DE_Results_Contrasts_GSE42264[[2]]
NamesOfTstatColumns_GSE42264 <- DE_Results_Contrasts_GSE42264[[3]]
ComparisonsOfInterest_GSE42264 <- c("GSE42264_Measles_vs_Control")

# GSE44331
NamesOfFoldChangeColumns_GSE44331 <- DE_Results_Contrasts_GSE44331[[2]]
NamesOfTstatColumns_GSE44331 <- DE_Results_Contrasts_GSE44331[[3]]
ComparisonsOfInterest_GSE44331 <- c("GSE44331_VSV_vs_Control")

# GSE51365
NamesOfFoldChangeColumns_GSE51365 <- DE_Results_Contrasts_GSE51365[[2]]
NamesOfTstatColumns_GSE51365 <- DE_Results_Contrasts_GSE51365[[3]]
ComparisonsOfInterest_GSE51365 <- c("GSE51365_MVH68_WT_vs_Control", "GSE51365_MVH68_M_vs_Control")

# GSE53784
NamesOfFoldChangeColumns_GSE53784 <- DE_Results_Contrasts_GSE53784[[2]]
NamesOfTstatColumns_GSE53784 <- DE_Results_Contrasts_GSE53784[[3]]
ComparisonsOfInterest_GSE53784 <- c("GSE53784_WNV_vs_Control", "GSE53784_JEV_vs_Control")

# GSE91074
NamesOfFoldChangeColumns_GSE91074 <- DE_Results_Contrasts_GSE91074[[2]]
NamesOfTstatColumns_GSE91074 <- DE_Results_Contrasts_GSE91074[[3]]
ComparisonsOfInterest_GSE91074 <- c("GSE91074_VEEV_vs_Control")
```


```{r run_collapse_contrast_DEResults, cache = TRUE}
# Function use

# GSE30577
Collapsing_DEResults_GSE30577 <- CollapsingDEResults_OneResultPerGene("GSE30577",
                                                                      DE_Results_GSE30577_GoodAnnotation,
                                                                      ComparisonsOfInterest_GSE30577,
                                                                      NamesOfFoldChangeColumns_GSE30577,
                                                                      NamesOfTstatColumns_GSE30577)

# GSE42264
Collapsing_DEResults_GSE42264 <- CollapsingDEResults_OneResultPerGene("GSE42264",
                                                                      DE_Results_GSE42264_GoodAnnotation,
                                                                      ComparisonsOfInterest_GSE42264,
                                                                      NamesOfFoldChangeColumns_GSE42264,
                                                                      NamesOfTstatColumns_GSE42264)

# GSE44331
Collapsing_DEResults_GSE44331 <- CollapsingDEResults_OneResultPerGene("GSE44331",
                                                                      DE_Results_GSE44331_GoodAnnotation,
                                                                      ComparisonsOfInterest_GSE44331,
                                                                      NamesOfFoldChangeColumns_GSE44331,
                                                                      NamesOfTstatColumns_GSE44331)

# GSE51365
Collapsing_DEResults_GSE51365 <- CollapsingDEResults_OneResultPerGene("GSE51365",
                                                                      DE_Results_GSE51365_GoodAnnotation,
                                                                      ComparisonsOfInterest_GSE51365,
                                                                      NamesOfFoldChangeColumns_GSE51365,
                                                                      NamesOfTstatColumns_GSE51365)

# GSE53784
Collapsing_DEResults_GSE53784 <- CollapsingDEResults_OneResultPerGene("GSE53784",
                                                                      DE_Results_GSE53784_GoodAnnotation,
                                                                      ComparisonsOfInterest_GSE53784,
                                                                      NamesOfFoldChangeColumns_GSE53784,
                                                                      NamesOfTstatColumns_GSE53784)

# GSE91074
Collapsing_DEResults_GSE91074 <- CollapsingDEResults_OneResultPerGene("GSE91074",
                                                                      DE_Results_GSE91074_GoodAnnotation,
                                                                      ComparisonsOfInterest_GSE91074,
                                                                      NamesOfFoldChangeColumns_GSE91074,
                                                                      NamesOfTstatColumns_GSE91074)
```


### 9) Alignment of DE results from same models (mouse & rat)

Each dataset has DE results from a slightly different list of genes.

Depending on the exact tissue dissected, the sensitivity of the transcriptional 
profiling platform, the representation on the transcriptional profiling platform 
(for microarray), and the experimental conditions, the DE results from different 
datasets will also be in a slightly different order.

We want to align these results so that the DE results from each dataset are columns, 
with each row representing a different gene.

- GSE30577 - Mouse model

- GSE42264 - Mouse model

- GSE44331 - Mouse model

- GSE51365 - Mouse model

- GSE53784 - Mouse model

- GSE91074 - Mouse model

Since there are only mouse models, we would create one aligning function.
If there are both mouse and rat models, we would have to create two aligning 
functions, one for the mouse and one for the rat.

```{r func_align_same}
# Create a function to align all mouse DE results from different datasets into
# a single dataframe for Log2FC and SV
AligningMouseDatasets <- function(ListOfMouseDEResults){
  
  # Create a list to store the log2FC 
  Mouse_MetaAnalysis_FoldChange_Dfs <- list()
  
  # Loop through all mouse DE results
  for(i in c(1:length(ListOfMouseDEResults))){
    # When did the row name become IDs?
    # Extract the Log2FC values from each dataset and put them into separate list
    # The element from the "Collapsing_DEResults_" has the format of row names
    # as Entrez Gene ID and columns containing Log2FC values
    Mouse_MetaAnalysis_FoldChange_Dfs[[i]] <- data.frame(Mouse_EntrezGene.ID = row.names(ListOfMouseDEResults[[i]][[1]]),
                                                         ListOfMouseDEResults[[i]][[1]], 
                                                         stringsAsFactors = FALSE)
  }
  
  # Print the structure of the Log2FC lists
  print("Mouse_MetaAnalysis_FoldChange_Dfs:")
  print(str(Mouse_MetaAnalysis_FoldChange_Dfs))
  
  # ALign the DE results by Entrez Gene ID and turn them into a single dataframe
  # join_all can be used for object of list class
  Mouse_MetaAnalysis_FoldChanges <<- join_all(Mouse_MetaAnalysis_FoldChange_Dfs, 
                                              by = "Mouse_EntrezGene.ID", 
                                              type = "full")

  # Print the structure of the aligned Log2FC 
  print("Mouse_MetaAnalysis_FoldChanges:")
  print(str(Mouse_MetaAnalysis_FoldChanges))
  
  # Create a list to store the SV 
  Mouse_MetaAnalysis_SV_Dfs <- list()
  
  # Loop through all mouse DE results 
  for(i in c(1:length(ListOfMouseDEResults))){
    # Extract the SV values from each dataset and put them into separate list
    # The element from the "Collapsing_DEResults_" has the format of row names
    # as Entrez Gene ID and columns containing SV values
    Mouse_MetaAnalysis_SV_Dfs[[i]] <- data.frame(Mouse_EntrezGene.ID = row.names(ListOfMouseDEResults[[i]][[4]]),
                                                 ListOfMouseDEResults[[i]][[4]], 
                                                 stringsAsFactors = FALSE)
  }
  
  # Print the structure of the SV lists
  print("Mouse_MetaAnalysis_SV_Dfs:")
  print(str(Mouse_MetaAnalysis_SV_Dfs))
  
  # ALign the DE results by Entrez Gene ID and turn them into a single dataframe
  # join_all can be used for object of list class
  Mouse_MetaAnalysis_SV <<- join_all(Mouse_MetaAnalysis_SV_Dfs, 
                                    by = "Mouse_EntrezGene.ID",
                                    type = "full")

  # Print the structure of the aligned SV 
  print("Mouse_MetaAnalysis_SV:")
  print(str(Mouse_MetaAnalysis_SV))
  
  # Remove the temporary lists of Log2FC and SV
  rm(Mouse_MetaAnalysis_SV_Dfs, Mouse_MetaAnalysis_FoldChange_Dfs)
}
```


```{r run_align_same, cache = TRUE}
# Prepare the list of collapsed mouse DE results
ListOfMouseDEResults <- list(Collapsing_DEResults_GSE30577, 
                             Collapsing_DEResults_GSE42264,
                             Collapsing_DEResults_GSE44331, 
                             Collapsing_DEResults_GSE51365,
                             Collapsing_DEResults_GSE53784, 
                             Collapsing_DEResults_GSE91074)

# Function use
AligningMouseDatasets(ListOfMouseDEResults)
```


### 10) Alignment of DE results from different models (mouse & rat)

#### Concept of *Gene Orthologs*:

- *Homology* refers to biological features including genes and their products that 
are descended from a feature present in a common ancestor.

- *Homologous gene* become separated in evolution in 2 different ways:

1. Separation of 2 populations with the ancestral gene into 2 species 

Gene separated by *speciation* are called *orthologs*.

2. Duplication of the ancestral gene within a lineage

Gene separated by *gene duplication* are called *paralogs*.

Ref: https://www.nlm.nih.gov/ncbi/workshops/2023-08_BLAST_evol/ortho_para.html

We have the ortholog database that we downloaded from Jackson Lab on April 25, 2024.
This database was trimmed and formatted using "FormattingRatMouseOrthologDatabase_20240425.R"

```{r join_database, cache = TRUE}
# Import the trimmed and formatted ortholog database
MouseVsRat_NCBI_Entrez <- read.csv("MouseVsRat_NCBI_Entrez_JacksonLab_20240425.csv",
                                   header = TRUE,
                                   stringsAsFactors = FALSE,
                                   row.names = 1,
                                   colClasses = c("character", "character", "character"))

# Join the ortholog database with mouse Log2FC

#### Problem arise here with the NA in the orthologs
Mouse_MetaAnalysis_FoldChanges_wOrthologs <- join(MouseVsRat_NCBI_Entrez, 
                                                  Mouse_MetaAnalysis_FoldChanges,
                                                  by = "Mouse_EntrezGene.ID",
                                                  type = "full")

# Join the ortholog database with mouse SV
Mouse_MetaAnalysis_SV_wOrthologs <- join(MouseVsRat_NCBI_Entrez,
                                         Mouse_MetaAnalysis_SV,
                                         by = "Mouse_EntrezGene.ID",
                                         type = "full")

# Check the structure of the new mouse Log2FC with ortholog info
str(Mouse_MetaAnalysis_FoldChanges_wOrthologs)

# Check the structure of the new mouse SV with ortholog info
str(Mouse_MetaAnalysis_SV_wOrthologs)
```


```{r join_orthologs_rat, eval = FALSE}
# If there are rat datasets, we want to join our mouse Log2FC and SV results to 
# the rat Log2FC and SV results using the ortholog info

# Join the Log2FC of the mouse datasets and rat datasets
MetaAnalysis_FoldChanges <- join(Mouse_MetaAnalysis_FoldChanges_wOrthologs,
                                 Rat_MetaAnalysis_FoldChanges,
                                 by = "Rat_EntrezGene.ID",
                                 type = "full")

# Check the structure of the joined mouse and rat Log2FC with ortholog info
str(MetaAnalysis_FoldChanges)
 
# Join the SV of the mouse datasets and rat datasets
MetaAnalysis_SV <- join(Mouse_MetaAnalysis_SV_wOrthologs,
                        Rat_MetaAnalysis_FoldChanges,
                        by = "Rat_EntrezGene.ID",
                        type = "full")

# Check the structure of the joined mouse and rat SV with ortholog info
str(MetaAnalysis_SV)
```


```{r join_orthologs_norat}
# If there are no rat dataset, we rename the dataframes so the pipeline code works
MetaAnalysis_FoldChanges <- Mouse_MetaAnalysis_FoldChanges_wOrthologs
MetaAnalysis_SV <- Mouse_MetaAnalysis_SV_wOrthologs

# Rename Mouse_Rat Entrez annotation for Log2FC dataframe
MetaAnalysis_FoldChanges$MouseVsRat_EntrezGene.ID <- paste(MetaAnalysis_FoldChanges$Mouse_EntrezGene.ID,
                                                           MetaAnalysis_FoldChanges$Rat_EntrezGene.ID, 
                                                           sep="_")

# Rename Mouse_Rat Entrez annotation for SV dataframe
MetaAnalysis_SV$MouseVsRat_EntrezGene.ID <- paste(MetaAnalysis_SV$Mouse_EntrezGene.ID, 
                                                  MetaAnalysis_SV$Rat_EntrezGene.ID, 
                                                  sep="_")

# Check the structure of the Log2FC dataframe
str(MetaAnalysis_FoldChanges)

# Check the structure of the SV dataframe 
str(MetaAnalysis_SV)
```


### 11) Comparison of Log2FC across datasets

```{r col_names_meta}
# Check the column names in the MetaAnalysis dataframes
colnames(MetaAnalysis_FoldChanges)
```

There are different ways to plot relationships across datasets:

1. Rank-rank hypergeometric overlap plots 

2. Hierarchically clustered heatmaps

We can generally compare the DE results associated with different contrasts 
using a scatter plot and correlation analysis.

```{r cor_matrix, cache = TRUE}
# Create a correlation matrix for Log2FC across datasets
# "pairwise.complete.obs" ignore any rows of DE results that do not have Log2FC 
# for one of our columns
MetaAnalysis_CorMatrix_FoldChanges <- cor(as.matrix(MetaAnalysis_FoldChanges[,-c(1:3)]), 
                                                    use = "pairwise.complete.obs",
                                                    method = "spearman")
# Check the correlation matrix
MetaAnalysis_CorMatrix_FoldChanges
```

Each cell includes the correlation coefficient reflecting the similarity of the 
effect sizes for the comparison of between the contrast in the row and the according
contrast in the column.

Correlation coefficient ranges between -1 to 1, with -1 being a perfect negative 
correlation and +1 being a perfect positive correlation

```{r heatmap, cache = TRUE}
# Illustrate the correlation matrix with hierarchically clustered heatmap

# Blues Palette
pheatmap(MetaAnalysis_CorMatrix_FoldChanges,
         display_numbers = TRUE,
         fontsize = 10,
         number_format = "%.2f", 
         color = colorRampPalette(brewer.pal(5, "Blues"))(100),
         border_color = "black",
         number_color = "black")

# Oranges Palette
pheatmap(MetaAnalysis_CorMatrix_FoldChanges,
         display_numbers = TRUE,
         fontsize = 10,
         number_format = "%.2f", 
         color = colorRampPalette(brewer.pal(5, "Oranges"))(100),
         border_color = "black",
         number_color = "black")

# Blues-Yellows Palette
pheatmap(MetaAnalysis_CorMatrix_FoldChanges,
         display_numbers = TRUE,
         fontsize = 10,
         number_format = "%.2f", 
         color = hcl.colors(5, "BluYl"),
         border_color = "black",
         number_color = "black")

# Viridis Palette
pheatmap(MetaAnalysis_CorMatrix_FoldChanges,
         display_numbers = TRUE,
         fontsize = 10,
         number_format = "%.2f", 
         color = viridis(5),
         border_color = "black",
         number_color = "black")

# The groups are placed in order by similarity, as determined by hierarchical clustering
# The lines ("tree branches") on the left and top illustrate that similarity (clustering) 
# using a "dendrogram"
```


### 12) Meta-analysis with random effect models

The meta-analysis is performed using the effect sizes (Log2FC) and sampling variances
(SV) for each gene stored in the objects *MetaAnalysis_FoldChanges* and *MetaAnalysis_SV*.

For any particular gene, it is likely that some datasets may be missing DE results.
This is especially true for genes that have low levels of expression and may not 
be detected by less sensitive assays. It is also likely to be true for genes that 
were discovered more recently (i.e., not targeted by older microarray platforms)
or that lack a clear ortholog in rat/mouse.

We can only run a meta-analysis if there DE results from more than 1 statistical
contrast. Since the DE results from the same study (dataset) are often artificially
correlated (especially if they use the same control group as the comparison), we 
would prefer that there are results from more than 1 dataset (not just more than
1 statistical contrast)

Before the meta-analysis, we need to decide the minimum number of DE results allowed
for a gene to be included.

```{r cal_NA_meta, cache = TRUE}
# Calculate the number of NAs (the number of statistical contrasts lacking DE
# results) in each row (for each gene)
MetaAnalysis_FoldChanges_NAsPerRow <- apply(MetaAnalysis_FoldChanges[,-c(1:3)], 
                                            1, 
                                            function(y) sum(is.na(y)))

# Visualize the distribution of the NAs with histogram
hist(MetaAnalysis_FoldChanges_NAsPerRow)

# Viusalize the distribution of the NAs with table 
table(MetaAnalysis_FoldChanges_NAsPerRow)

# This table tells us how many genes (rows) contain each number of NAs 
# Ex: There are 9979 genes that contain no NA, meaning that these 9979 genes can 
# be found across all datasets
# Ex: There are 5767 genes that contain 1 NA in 1 of the 8 contrasts
```


```{r func_meta}
# Create a function to run the meta-analysis
RunBasicMetaAnalysis <- function(NumberofComparisons,
                                 CutOffForNAs,
                                 MetaAnalysis_FoldChanges,
                                 MetaAnalysis_SV){
  
  # Calculate the number of NAs (the number of statistical contrasts lacking DE
  # results) in each row (for each gene)
  MetaAnalysis_FoldChanges_NAsPerRow <- apply(MetaAnalysis_FoldChanges[,-c(1:3)], 
                                              1, 
                                              function(y) sum(is.na(y)))
  
  # Print the number of NAs per gene
  print("Table of # of NAs per Row (Gene):")
  print(table(MetaAnalysis_FoldChanges_NAsPerRow))
  
  # Filter the genes with too many NAs
  MetaAnalysis_FoldChanges_ForMeta <- MetaAnalysis_FoldChanges[MetaAnalysis_FoldChanges_NAsPerRow < CutOffForNAs,]
  MetaAnalysis_SV_ForMeta <- MetaAnalysis_SV[MetaAnalysis_FoldChanges_NAsPerRow < CutOffForNAs,]
  
  # Print the structure of the filtered FC
  print("MetaAnalysis_FoldChanges_ForMeta:")
  print(str(MetaAnalysis_FoldChanges_ForMeta))
  
  # Print the structure of the filtered SV
  print("MetaAnalysis_SV_ForMeta:")
  print(str(MetaAnalysis_SV_ForMeta))
  
  # Create a matrix with 6 columns filled with NAs to store the meta-analysis results
  metaOutput <- matrix(NA, nrow(MetaAnalysis_FoldChanges_ForMeta), 6)
  
  # Loop through each gene to perform meta-analysis
  for(i in c(1:nrow(MetaAnalysis_FoldChanges_ForMeta))){
    
    # Extract the Log2FC and SV value for the current gene in numeric format
    # Remove the annotation columns prior to extraction
    fc <- as.numeric(MetaAnalysis_FoldChanges_ForMeta[i, -c(1:3)])
    sv <- as.numeric(MetaAnalysis_SV_ForMeta[i, -c(1:3)])
    
    # Perform meta-analysis using random-effect model that treat Log2FC across 
    # studies as random effects
    
    # Set the flag as FALSE 
    # This flag is used to determine if the current iteration should be skipped
    # due to an error
    skip_to_next <- FALSE
    
    # The "tryCatch" function will execute the code within "{}" block. If an error
    # occurs, the code in the "error" block is executed
    tryCatch({
      # Perform meta-analysis that treat Log2FC across studies as random effects
      TempMeta <- rma(fc, sv)
      # Store estimated Log2FC
      metaOutput[i,1] <- TempMeta$b
      # Store standard error of estimate
      metaOutput[i,2] <- TempMeta$se
      # Store p-value
      metaOutput[i,3] <- TempMeta$pval
      # Store lower bound of the confidence interval
      metaOutput[i,4] <- TempMeta$ci.lb
      # Store the upper bound of the confidence interval
      metaOutput[i,5] <- TempMeta$ci.ub
      # Store the number of comparisons with available data
      metaOutput[i,6] <- NumberOfComparisons-sum(is.na(fc))
    },
      # If an error occurs during the meta-analysis, the "error" function sets
      # "skip_to_next" to TRUE
      error = function(e){skip_to_next <<- TRUE})
    
    # If "skip_to_next" is TRUE, the "next" statement skips the current iteration
    # and move to the next gene 
    if(skip_to_next) next
    
    # Remove temporary variables
    rm(fc, sv)
  } 
  
  # Name the columns in the output
  colnames(metaOutput) <- c("Log2FC_estimate", 
                            "SE", 
                            "pval", 
                            "CI_lb", 
                            "CI_ub", 
                            "Number_Of_Comparisons")
  
  # Assign the combined mouse-rat entrez ID as row names of the output 
  row.names(metaOutput) <- MetaAnalysis_FoldChanges_ForMeta[,3]
  
  # Print the structure of the output
  print("metaOutput:")
  print(str(metaOutput))
  
  # Print the top of the output 
  print("Top of metaOutput:")
  print(head(metaOutput))
  
  # Print the bottom of the output 
  print("Bottom of metaOutput:")
  print(tail(metaOutput))
  
  # Change the format of the output to dataframe for the final list
  metaOutput <- as.data.frame(metaOutput)
  
  # Return the output and the annotation as separated lists
  return(list(metaOutput = metaOutput, 
              MetaAnalysis_Annotation = MetaAnalysis_FoldChanges_ForMeta[, c(1:3)],
              MetaAnalysis_FoldChanges_ForMeta = MetaAnalysis_FoldChanges_ForMeta,
              MetaAnalysis_SV_ForMeta = MetaAnalysis_SV_ForMeta))
}
```


```{r run_meta, cache = TRUE}
# Set up number of comparisons and cut off for NAs
# The number of NA = CutOffForNAs - 1
# Ex: 0 NA => CutOffForNA = 1
# Ex: 1 NA => CutOffForNA = 2

# There are 8 contrasts and we want genes that are available in all 8 contrasts
NumberOfComparisons = 8
CutOffForNAs = 1

# Function use 
# Meta-analysis with 0 NA
MetaAnalysis_Results_0NA <- suppressWarnings(
  RunBasicMetaAnalysis(NumberOfComparisons,
                       CutOffForNAs,
                       MetaAnalysis_FoldChanges,
                       MetaAnalysis_SV)
)

# Separate the meta-analysis output and annotation 
# 0 NA
metaOutput_0NA <- MetaAnalysis_Results_0NA[[1]]
MetaAnalysis_Annotation_0NA <- MetaAnalysis_Results_0NA[[2]]
MetaAnalysis_FoldChanges_ForMeta_0NA <- MetaAnalysis_Results_0NA[[3]]
MetaAnalysis_SV_ForMeta_0NA <- MetaAnalysis_Results_0NA[[4]]
```


### 13) Correction of p-value using Benjamini-Hochberg method

```{r join_database_2}
# Import database containing more detailed gene annotation
HOM_MouseVsRat <- read.csv("HOM_MouseVsRat_20240425.csv", header = TRUE, row.names = 1)

# Check the names of the columns of the database 
colnames(HOM_MouseVsRat)

# Change the format of the column names to character
HOM_MouseVsRat$Mouse_EntrezGene.ID <- as.character(HOM_MouseVsRat$Mouse_EntrezGene.ID)
HOM_MouseVsRat$Rat_EntrezGene.ID <- as.character(HOM_MouseVsRat$Rat_EntrezGene.ID)
```


```{r func_FDR}
# Create a function to correct FDR and extract genes with FDR > 0.05 and 0.1
FalseDiscoveryCorrection <- function(NumberOfNAs,
                                     metaOutput,
                                     HOM_MouseVsRat,
                                     MetaAnalysis_Annotation){
  
  # Calculate the FDR (q-value) for each p-value using the Benjamini-Hochberg method
  tempPvalAdjMeta <- mt.rawp2adjp(metaOutput[, 3], proc = c("BH"))
  
  # Re-order the FDR to match with the original order 
  metaPvalAdj <- tempPvalAdjMeta$adjp[order(tempPvalAdjMeta$index), ]
  
  # Add the FDR column to the meta-analysis output
  metaOutputFDR <- cbind(metaOutput, FDR = metaPvalAdj[, 2])
  
  # Rename the column to "FDR"
  colnames(metaOutputFDR)[7] <- "FDR"
  
  # Print the structure of meta-analysis output with FDR
  print("Meta-analysis output with FDR:")
  print(str(metaOutputFDR))
  
  # Add annotations to the output
  TempDF <- cbind(metaOutputFDR, MetaAnalysis_Annotation)
  
  # Add detailed gene annotations for mouse genes
  TempDF2 <- join(TempDF, 
                  HOM_MouseVsRat[, c(4:5, 9:11)], 
                  by = "Mouse_EntrezGene.ID", 
                  type = "left",
                  match = "first")
  
  # Add detailed gene annotations for rat genes
  TempDF3 <- join(TempDF2, 
                  HOM_MouseVsRat[, c(15:16, 20:22)], 
                  by = "Rat_EntrezGene.ID",
                  type = "left",
                  match = "first")
  
  # Save the annotated results to the meta-analysis output 
  metaOutputFDR_annotated <- TempDF3
  
  # Export the annotated meta-analysis output into the working directory 
  # (remove the row names as entrez ID have been merged into the dataframe)
  write.csv(metaOutputFDR_annotated, 
            paste("metaOutputFDR_Annotated_", NumberOfNAs, "NA.csv", sep = ""), 
            row.names = FALSE)
  
  # Order the results by p-value 
  # The results are ordered by p-values because close p-values can result in the same
  # FDR due to the restriction of the algorithm (the bending of FDR)
  metaOutputFDR_OrderbyPval <- metaOutputFDR_annotated[order(metaOutputFDR_annotated$pval), ]
  
  # Export the ordered, annotated meta-analysis output into the working directory 
  # (remove the row names as entrez ID have been merged into the dataframe)
  write.csv(metaOutputFDR_OrderbyPval, 
            paste("metaOutputFDR_OrderedByPval_", NumberOfNAs, "NA.csv",sep = ""), 
            row.names = FALSE)
  
  # Print genes with FDR < 0.1 
  print("# of genes that are statistically significant following loose FDR correction (FDR < 0.10):")
  print(sum(metaOutputFDR_annotated$FDR < 0.10, na.rm = TRUE))
  
  # Print genes with FDR < 0.05
  print("# of genes that are statistically significant following traditional FDR correction (FDR < 0.05):")
  print(sum(metaOutputFDR_annotated$FDR < 0.05, na.rm = TRUE))
  
  # Print top results in mouse genes
  print("Top 20 results ordered by p-values in mouse genes:")
  print(head(metaOutputFDR_OrderbyPval$Mouse_Symbol, 20))
  
  # Print top results in mouse genes
  print("Top 20 results ordered by p-values in rat genes:")
  print(head(metaOutputFDR_OrderbyPval$Rat_Symbol, 20))
  
  # Return the annotated output and ordered output with FDR 
  return(list(metaOutputFDR = metaOutputFDR,
              metaOutputFDR_annotated = metaOutputFDR_annotated,
              metaOutputFDR_OrderbyPval = metaOutputFDR_OrderbyPval))
  
  # Remove temporary objects
  rm(tempPvalAdjMeta, metaPvalAdj, TempDF, TempDF2)
}

# Have a few hundreds genes survived FDR < 0.05 => Add threshold for Log2FC? Common threshold? 0.5/0.2
```


```{r run_FDR, cache = TRUE}
# Function use 

# Meta-analysis with 0 NA 
metaOutputFDR_all_0NA <- FalseDiscoveryCorrection(0,
                                                 metaOutput_0NA,
                                                 HOM_MouseVsRat,
                                                 MetaAnalysis_Annotation_0NA)

# Because all 6 datasets are from mouse models, we would focus more on mouse
# gene symbols

# Separate the FDR outputs into individual objects 

# FDR output only 
metaOutputFDR_0NA <- metaOutputFDR_all_0NA[[1]]

# FDR output with annotations
metaOutputFDR_Annotated_0NA <- metaOutputFDR_all_0NA[[2]]

# FDR output ordered by p-values 
metaOutputFDR_OrderByPval_0NA <- metaOutputFDR_all_0NA[[3]]
```


### 14) Forest plots for statistically significant genes 

```{r check_range}
# Check the range of Log2FC values
hist(metaOutputFDR_0NA[, 1], breaks = 40) 
```


```{r func_forest_plot}
# Create a function to generate forest plot
MakeForestPlots <- function(metaOutputFDR_annotated, 
                            GeneSymbol, 
                            species, 
                            MetaAnalysis_FoldChanges_ForMeta,
                            MetaAnalysis_SV_ForMeta){
   if (species == "Mouse"){
    gene_row <- metaOutputFDR_annotated[metaOutputFDR_annotated$Mouse_Symbol == GeneSymbol, ][1,]
  } else if (species == "Rat"){
    gene_row <- metaOutputFDR_annotated[metaOutputFDR_annotated$Rat_Symbol == GeneSymbol, ][1,]
  } else {
    stop("Please use either 'Mouse' or 'Rat' to indicate whether you are using annotation for mouse or rat genes")
  }
  
  # Check if the gene exists
  if (nrow(gene_row) == 0){
    stop(paste("No gene found for symbol:", GeneSymbol))
  }
  
  # Extract gene symbols
  MouseGeneSymbol <- gene_row$Mouse_Symbol
  RatGeneSymbol <- gene_row$Rat_Symbol
  
  # Extract Log2FC and SV 
  if (species == "Mouse"){
    fc <- as.numeric(MetaAnalysis_FoldChanges_ForMeta[MetaAnalysis_FoldChanges_ForMeta$Mouse_EntrezGene.ID == gene_row$Mouse_EntrezGene.ID, -c(1:3)])
    sv <- as.numeric(MetaAnalysis_SV_ForMeta[MetaAnalysis_FoldChanges_ForMeta$Mouse_EntrezGene.ID == gene_row$Mouse_EntrezGene.ID, -c(1:3)])
  } else if (species == "Rat"){
    fc <- as.numeric(MetaAnalysis_FoldChanges_ForMeta[MetaAnalysis_FoldChanges_ForMeta$Rat_EntrezGene.ID == gene_row$Rat_EntrezGene.ID, -c(1:3)])
    sv <- as.numeric(MetaAnalysis_SV_ForMeta[MetaAnalysis_FoldChanges_ForMeta$Rat_EntrezGene.ID == gene_row$Rat_EntrezGene.ID, -c(1:3)])
  }
  
  # Create the filename for the output plot
  filename <- paste("ForestPlot_Mouse_", GeneSymbol, "_Rat_", RatGeneSymbol, ".png", sep = "")
  
  # Open a PNG device with specified resolution
  png(filename, height = 5, width = 8, units = "in", res = 300)
  
  # Create the forest plot
  forest.rma(rma(fc, sv), 
             slab = colnames(MetaAnalysis_FoldChanges_ForMeta)[-c(1:3)], 
             xlim = c(-7, 7), 
             cex = 0.75)
  
  # Add labels to the plot
  mtext(paste("Mouse:", GeneSymbol, "_Rat:", RatGeneSymbol, sep = ""), 
        line = -1.5, 
        cex = 1.5)
  
  # Close the PNG device
  dev.off()
}
```


```{r run_forest_plot, cache = TRUE}
# Function use 

# Ppp2r5a
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Ppp2r5a",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Cdhr1
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Cdhr1",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Sema5b
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Sema5b",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Sema7a
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Sema7a",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)
```


**Interpretation of Forest Plots**

**1. Study Labels (Left Side)**

- The labels on the left side of the plot indicate the individual contrasts included
in the meta-analysis.

**2. Effect Sizes and Confidence Intervals (Right side)**

- Each horizontal line represents the effect size (Log2FC) for a particular contrast
along with its confidence interval. The squares represent the point of estimate of 
the effect size for each contrast. The horizontal lines extending from the squares
are the confidence intervals for the effect size.

- The size of the squares represent the weight of each contrast in the meta-analysis,
with larger square indicating more weight.


**3. Overall Effect (Bottom)**

- The diamond shape at the bottom of the plot represents the overall effect size 
calculated from the meta-analysis (random-effects model).

- The width of the diamond represents the confidence interval for the overall effect
size.

**4. X-axis (Observed Outcome)**

- The x-axis shows the scale/range for the effect sizes (Log2FC).

- The vertical dash line at 0 indicate no effect. Effect sizes to the left of this 
line suggest a decrease, while those to the right suggest an increase.
