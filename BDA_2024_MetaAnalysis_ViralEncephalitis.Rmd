---
title: "BDA_2024_MetaAnalysis_ViralEncephalitis"
author: "Duy Nguyen"
date: "2024-07-22"
output:  
  pdf_document:
    latex_engine: xelatex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Research Guide of Meta-Analysis of Transcriptomics Profile in Viral Encephalitis

**Step 1:** Project set up with necessary packages

**Step 2:** Search for dataset in Gemma using individual search terms, including:

- Relevant search terms

- Specific virus names with capabilities for causing encephalitis

Datasets included for meta-analysis: GSE30577, GSE42264, GSE44331, GSE51365,
GSE53784, GSE91074

**Step 3:** Assess gene expression range 

Some datasets, especially Agilent microarray datasets, were normalized incorrectly,
which may require re-normalization.

*Function:* 

- `CheckGeneExpressionRange()`: Function to check expression range of the dataset

**Step 4:** Extract statistical contrasts of differential analysis in the datasets

These statistical contrasts allow us to check if the differential analyses are:

- Subsetted by brain region 

- Included unwanted subjects

- Set up in an appropriate manner with the reference group

Based on the statistical contrasts, we might need to re-run the differential analysis

*Function:*

- `GettingResultSetInfoForDatasets()`: Function to extract statistical contrasts of 
differential analysis in each dataset

*Output object:* 

- ResultSets_toScreen

- ExperimentIDs

**Step 5:** Download the differential expression (DE) results from each dataset 

*Functions:*

- `DownloadingDEResults()`: Function to download DE results and extract Log2FC and 
T-stat for contrasts of interest

- `SavingGemmaDEResults_forEachResultSet()`: Function to save DE results for each
ResultSet into the working directory

*Output objects:* 

- ResultSets_contrasts (Rename of ResultSets_Screened)

- UniqueResultSetIDs

- differentials 

- DEResults_GSE#####_######

**Step 6:** Filter DE results for rows with good gene annotation

*Function:*

- `FilteringDEResults_GoodAnnotation()`: Function to filter rows with good gene 
annotation

*Output objects:*

- DEResults_GSE##### (Separated from "differentials")

- DE_Results_GSE#####_GoodAnnotation 

**Step 7:** Extract DE results for the contrasts of interest

*Functions:*

- `GetContrastIDsforResultSet()`: Function to extract the contrast ID using FC column 
names (Used within function `ExtractingDEResultsForContrasts()`)

- `ExtractingDEResultsForContrasts()`: Function to extract DE results for contrasts
of interest

- `GetContrastStatColumns()`: Function to extract the Log2FC and T-stat of contrasts
of interest

*Output objects:*

- Contrast_Log2FC_GSE###### | Contrast_Tstat_GSE##### | ComparisonOfInterest_GSE#####

- DE_Results_Contrasts_GSE#####

**Step 8:** Collapse DE results to one result per gene & Calculate standard error
and sampling variance

Gene expression can be measured using multiple probes (microarray). Therefore,
DE results need to be collapsed to one result per gene.

Log2FC: Log 2 of the fold change values between 2 groups 

T-statistics: The ratio of the difference in a number's estimated value from its
assumed value to its standard error

Standard error of Log2FC = Log2FC/T-statistics

Sampling variance = Average of standard error of each gene^2

*Function:*

- `CollapsingDEResults_OneResultPerGene()`: Function to average Log2FC, Tstat, standard
error (SE) and calculate sampling variance (SV) to one unique gene per dataset 

*Output objects:*

- NameOfFoldChangeColumns_GSE##### | NameOfTstatColumns_GSE#####

- Collapsing_DEResults_GSE##### folder with 4 different objects:

DEResults_GSE#####_GoodAnnotation_FoldChange_AveragedByGene

DE_Results_GSE#####_GoodAnnotation_Tstat_AveragedByGene

DE_Results_GSE#####_GoodAnnotation_SE_AveragedByGene

DE_Results_GSE#####_GoodAnnotation_SV


**Step 9:** Align DE results from same models (either from mouse model or rat model)

As DE results from different datasets are in slightly different orders due to 
various experimental factors, we want to align these results so that the DE results 
from each dataset are columns, with each row representing a different gene.

*Function:*

- `AligningMouseDatasets()`: Function to align all mouse DE results from different
datasets into a single dataframe for Log2FC and SV

*Output objects:*

- Mouse_MetaAnalysis_FoldChanges

- Mouse_MetaAnalysis_SV

**Step 10:** Align DE results from different models (combine DE results from both 
mouse model and rat model using the ortholog database from Jackson Lab) 

###### Problem with extra NA when joining the original dataframe with the ortholog database

*Output Objects:*

- MouseVsRat_NCBI_Entrez

- Mouse_MetaAnalysis_FoldChanges_wOrthologs

- Mouse_MetaAnalysis_SV_wOrthologs

- MetaAnalysis_FoldChanges

- MetaAnalysis_SV

**Step 11:** Compare Log2FC across datasets with correlation matrix and hierarchically 
clustered heatmap

*Output Objects:*

- MetaAnalysis_CorMatrix_FoldChanges

- Hierarchically clustered heatmaps 

**Step 12:** Meta-analysis with random effect models

Meta-analysis is performed using effect sizes (Log2FC) and sampling variances (SV)

*Function:*

- `RunBasicMetaAnalysis()`: Function to perform meta-analysis

*Output Objects:*

- MetaAnalysis_FoldChanges_NAsPerRow

- CutOffForNAs

- NumberOfComparisons

- MetaAnalysis_Results_0NA

- metaOutput_0NA | MetaAnalysis_Annotation_0NA | MetaAnalysis_FoldChanges_ForMeta_0NA |
MetaAnalysis_SV_ForMeta_0NA (Separated from MetaAnalysis_Results_0NA)

**Step 13:** Correct p-value for each gene using Benjamini-Hochberg method for 
False Discovery Rate (FDR or q-value)

*Function:*

- `FalseDiscoveryCorrection()`: Function to correct FDR and extract gene with certain
threshold of FDR and Log2FC

*Output Objects:*

- HOM_MouseVsRat

- metaOutputFDR_all_0NA

- metaOutputFDR_0NA | metaOutputFDR_Annotated_0NA | metaOutputFDR_OrderByPval_0NA |
metaOutputFDR_OrderbyPval_Log2FC_2_0NA | metaOutputFDR_OrderbyPval_Log2FC_1_0NA |
metaOutputFDR_OrderbyPval_Log2FC_0.5_0NA (Separated from metaOutputFDR_all_0NA)

**Step 14:** Create forest plots for statistically significant genes 

*Function:*

- `MakeForestPlots()`: Function to generate forest plots

*Output Objects:*

- Forest plots of statistically significant genes

**Step 15:** Retrieve gene function from NCBI using Entrez ID

*Function:*

- `GetGeneFunctionByID()`: Function to get gene function from NCBI using Entrez 
Gene ID 

*Output Objects:*

- EntrezGeneList_Log2FC_1_0NA

- GeneFunction_Log2FC_1_0NA

**Step 16:** Enrichment Analysis with KEGG/GO/Reactome databases

*Function:*

- `GSEAPerform_KEGG_GO_Reactome()`: Function to perform GSEA on common databases, 
including KEGG, GO, and Reactome

*Output Object:*

- KEGG_metaOutputFDR_Log2FC_#_0NA_FDR_0.05

- KEGGgenedata_metaOutputFDR_Log2FC_#_0NA

- mmu04061

- mmu04621

- mmu05164

- GSEA_Log2FC_#_0NA

- GSEA_Log2FC_#_0NA_KEGG

- GSEA_Log2FC_#_0NA_GO

- GSEA_Log2FC_#_0NA_Reactome

**Step 17:** Fast Gene Set Enrichment Analysis with Brain.GMT database (developed by
Dr. Hagenauer)

*Output Object:*

- BrainGMTgenedata_metaOutputFDR_Log2FC_#_0NA

- BrainGMTgenedata_metaOutputFDR_Log2FC_#_0NA_cleaned

- BrainGMTgenedata_metaOutputFDR_OrderedByLog2FC_#_0NA

- BrainGMT_Mouse

- GSEA_Log2FC_#_0NA_BrainGMT


### 1) Project Set Up

```{r setdw, eval = FALSE, echo = FALSE}
# Set working directory 
setdw("/Users/manhduynguyen/BDA_2024_ViralEncephalitis")
```


```{r renv, eval = FALSE, echo = FALSE}
# Initiate the project with renv
renv::init()

# Save to lockfile
renv::snapshot()
```


```{r install_pack, eval = FALSE, echo = FALSE}
# Download packages
if(!requireNamespace("devtools", quietly = T)){
  install.packages("devtools")
}
devtools:: install_github("PavlidisLab/gemma.R", force = T)

# Do not update any packages when prompted to do so
if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install("multtest")                                 
BiocManager::install("clusterProfiler")
# Mus musculus (Mouse gene annotation database)
# Other databases include:
# 1. Rattus norvegicus (Rat) - org.Rn.eg.db
# 2. Homo sapiens (Human) - org.Hs.eg.db
BiocManager::install("org.Mm.eg.db")  
BiocManager::install("ReactomePA")  
BiocManager::install("fgsea")
BiocManager::install("pathview")

install.packages("plyr")
install.packages("metafor")
install.packages("tidyverse")
install.packages("writexl")
install.packages("pheatmap")
install.packages("RColorBrewer")
install.packages("viridis")
install.packages("rentrez")
```


```{r load_pack, message = FALSE}
# Load packages
library("gemma.R")
library("plyr")
library("metafor")
library("tidyverse")
library("writexl")
library("pheatmap")
library("RColorBrewer")
library("viridis")
library("multtest")
library("rentrez")
library("clusterProfiler")
library("org.Mm.eg.db")
library("ReactomePA")
library("fgsea")
library("pathview")

# Check loaded packages 
(.packages())
```


### 2) Gemma Dataset Search

```{r data_search, eval = FALSE}
# Extract datasets from Gemma based on single search terms
Sepsis <- searchDatasets("Sepsis", limit = 100)
Encephalitis <- searchDatasets("Encephalitis", limit = 100)
Viral_Encephalitis <- searchDatasets("Viral Encephalitis", limit = 100)
Neuroinflammation <- searchDatasets("Neuroinflammation", limit = 100)
Neuroimmune <- searchDatasets("Neuroinmmune", limit = 100)
Neuroimmunology <- searchDatasets("Neuroinmmunology", limit = 100)
Neurotoxicity <- searchDatasets("Neurotoxicity", limit = 100)
Neuroimmunity <- searchDatasets("Neuroimmunity", limit = 100)
Neuroinflame <- searchDatasets("Neuroinflame", limit = 100)
Neuroinflammatory <- searchDatasets("Neuroinflammatory", limit = 100)
Neurotropic <- searchDatasets("Neurotropic", limit = 100)
Neuroinvasive <- searchDatasets("Neuroinvasive", limit = 100)
Neurovirulence <- searchDatasets("Neurovirulence", limit = 100)
Viral <- searchDatasets("Viral", limit = 100)
Virus <- searchDatasets("Virus", limit = 100)
Infection <- searchDatasets("Infection", limit = 100)
Viral_Infection <- searchDatasets("Viral Infection", limit = 100)
Brain_Infection <- searchDatasets("Brain Infection", limit = 100)
Brain_Inflammation <- searchDatasets("Brain Inflammation", limit = 100)
Brain_Immunology <- searchDatasets("Brain Immunology", limit = 100)
Brain_Inflammatory <- searchDatasets("Brain Inflammatory", limit = 100)

# Extract datasets from Gemma based on specific viruses
Zika <- searchDatasets("Zika", limit = 100)
Chikungunya <- searchDatasets("Chikungunya", limit = 100)
West_Nile <- searchDatasets("West Nile", limit = 100)
Japanese_encephalitis <- searchDatasets("Japanese encephalitis", limit = 100)
Venezuelan_encephalitis <- searchDatasets("Venezuelan encephalitis", limit = 100)
StLouis_encephalitis <- searchDatasets("St Louis encephalitis", limit = 100)
Polio <- searchDatasets("Polio", limit = 100)
Mumps <- searchDatasets("Mumps", limit = 100)
Measles <- searchDatasets("Measles", limit = 100)
Nipah <- searchDatasets("Nipah", limit = 100)
Hendra <- searchDatasets("Hendra", limit = 100)
Herpes <- searchDatasets("Herpes", limit = 100)
Varicella <- searchDatasets("Varicella zoster", limit = 100)
Epstein_Barr <- searchDatasets("Epstein Barr", limit = 100)
Cytomegalo <- searchDatasets("Cytomegalovirus", limit = 100)
Rabies <- searchDatasets("Rabies", limit = 100)
Influenza <- searchDatasets("Influenza", limit = 100)
Corona <- searchDatasets("Coronavirus", limit = 100)
Yellow_fever <- searchDatasets("Yellow fever", limit = 100)



# Extract the data to excel file
write_xlsx(Sepsis, "Sepsis.xlsx") 
write_xlsx(Encephalitis,"Encephalitis.xlsx")
write_xlsx(Viral_Encephalitis, "Viral Encephalitis.xlsx")
write_xlsx(Neuroinflammation, "Neuroinflammation.xlsx")
write_xlsx(Neuroimmunity,"Neuroimmunity.xlsx")
write_xlsx(Neuroinflammatory,"Neuroinflammatory.xlsx")
write_xlsx(Neurotoxicity,"Neurotoxicity.xlsx")
write_xlsx(Neurotropic,"Neurotropic.xlsx")
write_xlsx(Neuroinvasive, "Neuroinvasive.xlsx")
write_xlsx(Neurovirulence, "Neurovirulence")
write_xlsx(Viral, "Viral.xlsx")
write_xlsx(Viral_Infection,"Viral Infection.xlsx")
write_xlsx(Virus,"Virus.xlsx")
write_xlsx(Infection, "Infection.xlsx")

# Count the frequency of unique values in a dataframe
table(Sepsis$taxon.Name) #Count based on the model (human, mouse, rat)

# Combine and exclude datasets of other models than mouse/rat
Total_datasets = rbind(Brain_Immunology, Brain_Infection, Brain_Inflammation, 
                       Corona, Cytomegalo, Encephalitis, Epstein_Barr, Hendra, 
                       Herpes, Infection,Influenza,Japanese_encephalitis, Measles, 
                       Neuroinflammation, Neuroinflammatory, Neuroinvasive, 
                       Neurotoxicity, Neurotropic, Neurovirulence, Rabies, Sepsis, 
                       Varicella, Venezuelan_encephalitis, Viral, Viral_Encephalitis, 
                       Viral_Infection, Virus, West_Nile, Yellow_fever, Zika)
Total_datasets_eli_1 = subset(Total_datasets, Total_datasets$taxon.Name == "mouse")
Total_datasets_eli_2 = subset(Total_datasets, Total_datasets$taxon.Name == "rat")
Total_datasets_eli = unique(rbind(Total_datasets_eli_1, Total_datasets_eli_2))
write_xlsx(Total_datasets_eli, "Total datasets.xlsx")
```

Through process of inclusion/exclusion criteria, 6 datasets are included in the 
meta-analysis, including: GSE30577, GSE42264, GSE44331, GSE51365, GSE53784,
GSE91074.


### 3) Gene Expression Range Assessment

```{r func_check_gene_express}
# Create a function to check the expression range of the dataset 
# (especially for the Agilent microarray datasets)
CheckGeneExpressionRange <- function(dataset_shortname){
  
  # Retrieve the processed expression data for the given dataset
  expression_data <- get_dataset_processed_expression(dataset_shortname)
  
  # Print the structure of the expression data
  print(str(expression_data))
  
  # The first four columns are row metadata: Probe, GeneSymbol, GeneName, NCBI ID
  # The rest of the columns are gene expression values for each subject
  
  # Exclude metadata row (row 1-4) and convert the gene expression columns to a 
  # matrix for further analysis 
  expression_matrix <- as.matrix(expression_data[,-1:-4])
  
  # Create a histogram of the expression data 
  hist(expression_matrix, 
       main = paste("Histogram of Expression Data for", dataset_shortname),
       # The y-axis is the gene frequency
       # The x-axis is log 2 gene expression - log 2 counts per million
       xlab = "Log 2 Expression", ylab = "Frequency")
  
       # The large spike on the left side of the histogram ("floor effect") are 
       # all of the genes that are not truly expressed or have too low of expression 
       # to be measurable 
  
  # Log 2 RNA-seq dataset has the range between -5 to 12
  # Log 2 Microarray dataset has the range between 4 to 15
  
  # Calculate the min, median, max values of the expression data
  min_val <- min(expression_matrix, na.rm = TRUE)
  median_val <- median(expression_matrix, na.rm = TRUE)
  max_val <- max(expression_matrix, na.rm= TRUE)
  
  # Print the calculated values
  print(paste("Minimum value:", min_val))
  print(paste("Median value:", median_val))
  print(paste("Maximum value:", max_val))
}
```


```{r run_check_gene_express, cache = TRUE}
# Function use 
CheckGeneExpressionRange("GSE30577") # Min: -4.8 | Max: 8.6 | Agilent Microarray 
CheckGeneExpressionRange("GSE42264") # Min: 2.4 | Max: 14.6 | Affymetrix Array
CheckGeneExpressionRange("GSE44331") # Min: 2.9 | Max: 14.5 | Affymetrix Array
CheckGeneExpressionRange("GSE51365") # Min: 1.2 | Max: 15.7 | Affymetrix Array
CheckGeneExpressionRange("GSE53784") # Min: 2.0 | Max: 14.1 | Affymetrix Array
CheckGeneExpressionRange("GSE91074") # Min: 2.8 | Max: 14.3 | Affymetrix Array
```

Gene expression of all 6 datasets seem to be within normal range and have appropriate
distribution.


### 4) Extraction of Statistical Contrasts of Differential Analysis in Each Dataset

For the meta-analysis, we will be extracting the differential expression results 
from Gemma. The differential expression results for each dataset may include 
multiple result sets (e.g., one result set for the subset of the data from the 
hippocampus, one result set for frontal cortex). Each of these result sets may 
have multiple statistical contrasts (e.g., drug1 vs. vehicle, drug2 vs. vehicle). 
Therefore, each of the statistical contrasts is labeled with a result ID and 
contrast ID within the Gemma database. We will need to know which of these IDs 
are relevant to our project goals to easily extract their results.

We will also need to double-check that these statistical contrasts are set up in 
a manner that makes sense for our experiments:

1. For experiments that include more than one brain region, we will need to 
double-check that the results have been subsetted by brain region (instead of 
including brain region ("OrganismPart") as a factor in the model). If they have 
not been subsetted by region, we will probably need to re-run the differential 
expression analysis.

2. Depending on the goals of the meta-analysis, we may also need to re-run the 
differential expression analysis to remove other unwanted subjects (e.g., removing 
subjects with genotypes that might interfere with our results).

3. We will need to double-check that the comparisons include an appropriate 
reference group - sometimes they are reversed in Gemma (e.g., having the drug 
treatment set as the baseline, with vehicle as the manipulation). If this is the 
case, we will need to invert the effects when we input them into our meta-analysis 
(multiply the effects by -1).


```{r func_contrast_extract}
# Create a function to extract statistical contrasts of differential analysis 
# in each dataset 
GettingResultSetInfoForDatasets <- function(ExperimentIDs) {
  
  # Create a dataframe to store the results 
  resultsets_toscreen <- data.frame(
    ExperimentIDs = character(),
    ResultSetIDs = character(),
    ContrastIDs = character(),
    FactorCategory = character(),
    ExperimentalFactors = character(),
    BaselineFactors = character(),
    Subsetted = logical(),
    SubsetBy = character(),
    stringsAsFactors = FALSE
  )
  
  # Loop through each of the datasets 
  for (i in c(1:length(ExperimentIDs))) {
    
    # Extract the differential expression analysis from the datasets 
    design <- get_dataset_differential_expression_analyses(ExperimentIDs[i])
    
    # Check if the design dataframe has rows
    if (nrow(design) > 0) {
      
      # Create the vectors to store the experimental and baseline factors
      experimental_factors <- vector(mode = "character", length = nrow(design))
      baseline_factors <- vector(mode = "character", length = nrow(design))
      
      # Loop through each result.ID in the design dataframe
      for (j in c(1:nrow(design))) {
        
        # Concatenate the experimental factors into a single string
        experimental_factors[j] <- paste(design$experimental.factors[[j]]$summary, 
                                         collapse = ";")
        
        # Concatenate the baseline factors into a single string 
        baseline_factors[j] <- paste(design$baseline.factors[[j]]$summary, 
                                     collapse = ";")
      }
      
      # Create a vector to store subset information
      SubsetBy <- vector(mode = "character", length = nrow(design))
      
      # Check if the design dataframe is subsetted or not
      if (design$isSubset[1] == TRUE) {
        
        # Loop through each result.ID to extract and concatenate subset information
        for (j in c(1:nrow(design))) {
          SubsetBy[j] <- paste(design$subsetFactor[[j]]$summary, collapse = ";")
        } 
      } else {
        # If not subsetted, fill the SubsetBy vector with NA values 
        SubsetBy <- rep(NA, length(design$result.ID))
      }
      
      # Create a temporary dataframe to store extracted info
      resultsets_for_experiment <- data.frame(
        ExperimentIDs = ExperimentIDs[i],
        ResultSetIDs = design$result.ID,
        ContrastIDs = design$contrast.ID,
        FactorCategory = design$factor.category,
        ExperimentalFactors = experimental_factors,
        BaselineFactors = baseline_factors,
        Subsetted = design$isSubset,
        SubsetBy = SubsetBy,
        stringsAsFactors = FALSE
      )
      
      # Append the temporary dataframe with the dataframe created initially
      resultsets_toscreen <- rbind(resultsets_toscreen, resultsets_for_experiment)
      
    }
  }
  
  # Add empty columns to store screening notes 
  resultsets_toscreen <- cbind(
    resultsets_toscreen,
    Include = vector(mode = "character", length = nrow(resultsets_toscreen)),
    WrongBaseline = vector(mode = "character", length = nrow(resultsets_toscreen)),
    ResultsNotRegionSpecific = vector(mode = "character", length = nrow(resultsets_toscreen)),
    ReAnalyze = vector(mode = "character", length = nrow(resultsets_toscreen)),
    stringsAsFactors = FALSE
  )
  
  # Export the final dataframe into the working directory
  write.csv(resultsets_toscreen, "ResultSets_toScreen.csv")
  
  # Print a message to indicate that the results have been saved 
  print("Output object: ResultSets_toScreen.csv")
}
```


```{r run_contrast_extract, cache = TRUE}
# Set up a vector of the names of all datasets
ExperimentIDs <- c("GSE30577", "GSE42264", "GSE44331", 
                   "GSE51365", "GSE53784","GSE91074")

# Function use
GettingResultSetInfoForDatasets(ExperimentIDs)
```


### 5) Downloading the DE Results from Each Dataset

```{r func_download_DEResults}
# Create a function to download DE results and extract Log2FC and T-statistics 
# for contrasts of interest 
DownloadingDEResults <- function(ResultSets_contrasts){
  
  # Identify the unique ResultSet IDs
  # Some ResultSets may have multiple statistical contrasts, but we only want unique ResultSet IDs
  UniqueResultSetIDs <- unique(ResultSets_contrasts$ResultSetIDs) 
  
  # Print the identified unique ResultSet IDs
  print("ResultSets identified as being of interest:")
  print(UniqueResultSetIDs)
  
  # Download DE results for each unique ResultSet ID
  differentials <- UniqueResultSetIDs %>%
    # The function returns a list because single experiment may have multiple 
    # resultSets
    # Only take the first element of the output
    # The "resultSet" argument is used to directly access the results we need
    lapply(function(x) {get_differential_expression_values(resultSets = x)[[1]]})
  
  # Some datasets might not have all the advertised DE results due to a variety of
  # so we need to remove empty differential (only keep differential with rows present)
  non_missing_contrasts <- sapply(differentials, function(df) nrow(df) > 0)
  
  # Return the "differentials" object that contains the DE results of contrast of interest
  differentials <<- differentials[non_missing_contrasts] 
  UniqueResultSetIDs <<- UniqueResultSetIDs[non_missing_contrasts]
  
  # Print the ResultSet IDs that had DE results
  print("ResultSets that had DE results:")
  print(UniqueResultSetIDs)
  
  # Print a message to inform the structure of the output "differentials"
  print("Your DE results for each of the ResultSets are stored in object differentials.")
  print("This object is structured as a list of dataframes.")
  print("Each element in the list represents a ResultSet, with the dataframe containing DE results")
  
  # Extract the effect sizes of Log2FC of contrasts of interest
  print("Columns of effect sizes (Log2FC) for contrasts of interest:")
  Contrasts_Log2FC <- paste("contrast_", ResultSets_contrasts$ContrastIDs, 
                             "_log2fc", sep = "")
  print(Contrasts_Log2FC)
  
  # Extract the T-statistics of contrasts of interest for calculating sampling variances
  print("Columns of T-statistics for contrasts of interest:")
  Contrasts_Tstat <- paste("contrast_", ResultSets_contrasts$ContrastIDs,
                            "_tstat", sep = "")
  print(Contrasts_Tstat)
  
  # Remove the temporary Log2FC and T-statistics of contrast of interest
  rm(Contrasts_Log2FC, Contrasts_Tstat)
}
```


```{r run_download_DEResults, cache = TRUE}
# Import the CSV file with contrasts of interest
ResultSets_contrasts <- read.csv("ResultSets_Screened.csv", 
                                 header = TRUE, stringsAsFactors = FALSE)
# Function use
DownloadingDEResults(ResultSets_contrasts)

# Check the structure of the "differentials" object
str(differentials)
```


```{r func_save_DEResults}
# Create a function to save DE results for each ResultSet
SavingGemmaDEResults_forEachResultSet <- function(differentials, 
                                                  UniqueResultSetIDs, 
                                                  ResultSets_contrasts){
    
  # Loop through each dataset (list element) in "differentials" object
  for (i in c(1:length(differentials))){
    
    # Get the current ResultSet ID
    ThisResultSet <- UniqueResultSetIDs[i]
    
    # Get the dataset ID corresponding to the current ResultSet ID
    # Some datasets have multiple ResultSets, so take the dataset ID from the 
    # first matching entry
    ThisDataSet <- ResultSets_contrasts$ExperimentID[ResultSets_contrasts$ResultSetIDs == ThisResultSet][1] 
    
    # Export the DE results for the current ResultSet ID into the working directory
    write.csv(differentials[[i]], paste("DEResults_", ThisDataSet, "_", ThisResultSet, ".csv", sep=""))
    
    # Remove the temporary IDs
    rm(ThisDataSet, ThisResultSet)
   }
  
  # Print a message to indicate the DE results have been exported into working directory
  print("Output object: DEResults_Dataset ID_ResultSet ID")
}
```


```{r run_save_DEResults, cache = TRUE}
# Function use
SavingGemmaDEResults_forEachResultSet(differentials, 
                                      UniqueResultSetIDs,
                                      ResultSets_contrasts)
```


### 6) Filter of DE results for rows with good gene annotation

```{r func_gene_filter}
# Create a function to filter for rows with good gene annotation 
FilteringDEResults_GoodAnnotation <- function(DE_Results){
  
  # Print the total number of rows in the DE results
  print("# of rows in results")
  print(nrow(DE_Results))
  
  # Print the number of rows with missing NCBI annotation
  print("# of rows with missing NCBI annotation:")
  print(sum(DE_Results$NCBIid == "" | DE_Results$NCBIid == "null", na.rm = TRUE))
  
  # Print the number of rows with NA NCBI annotation
  print("# of rows with NA NCBI annotation:")
  print(sum(is.na(DE_Results$NCBIid)))
  
  # Print the number of rows with missing Gene Symbol annotation
  print("# of rows with missing Gene Symbol annotation:")
  print(sum(DE_Results$GeneSymbol == ""| DE_Results$GeneSymbol == "null", na.rm = TRUE))
  
  # Print the number of rows mapped to multiple NCBI IDs
  print("# of rows mapped to multiple NCBI IDs:")
  print(length(grep('\\|', DE_Results$NCBIid)))
  
  # Print the number of rows mapped to multiple Gene Symbols
  print("# of rows mapped to multiple Gene Symbols:")
  print(length(grep('\\|', DE_Results$GeneSymbol)))
  
  # Subset data containing rows with valid NCBI EntrezID (non-empty and non-null)
  DE_Results_NoNA <- DE_Results[(DE_Results$NCBIid == "" | 
                                 DE_Results$NCBIid == "null") == FALSE & 
                                 is.na(DE_Results$NCBIid) == FALSE,]
  
  # Subset data annotated with a single gene (not ambiguously mapped to more 
  # than one gene)
  if(length(grep('\\|', DE_Results_NoNA$NCBIid)) == 0){
    # If there are no rows with multiple NCBI IDs, use the current subset
    DE_Results_GoodAnnotation <- DE_Results_NoNA
  } else {
    # Extract only rows annotated with a single Gene Symbol (no pipe character '|')
    DE_Results_GoodAnnotation <- DE_Results_NoNA[-(grep('\\|', DE_Results_NoNA$NCBIid)),]
  }

  # Print the number of rows with good annotation
  print("# of rows with good annotation")
  print(nrow(DE_Results_GoodAnnotation))
  
  # Get the name of the input object as a string for file naming
  ID <- deparse(substitute(DE_Results))
  
  # Export the DE results with good annotations into the working directory
  write.csv(DE_Results_GoodAnnotation, paste(ID, "_GoodAnnotation.csv", sep = ""))
  
  # Remove the temporary DE result objects
  rm(DE_Results_NoNA, DE_Results)
  
  # Print a message to the DE results with good annotations have been exported 
  # into working directory 
  print(paste("Output object:", ID, "_GoodAnnotation.csv", sep = ""))
  
  # Return the DE results with good annotation into the environment
  return(DE_Results_GoodAnnotation)
}
```


```{r run_gene_filter, cache = TRUE}
# Separate the DE results from object "differentials"
DEResults_GSE30577 <- differentials[[1]]
DEResults_GSE42264 <- differentials[[2]]
DEResults_GSE44331 <- differentials[[3]]
DEResults_GSE51365 <- differentials[[4]]
DEResults_GSE53784 <- differentials[[5]]
DEResults_GSE91074 <- differentials[[6]]

# Function use
DE_Results_GSE30577_GoodAnnotation <- FilteringDEResults_GoodAnnotation(DEResults_GSE30577)
DE_Results_GSE42264_GoodAnnotation <- FilteringDEResults_GoodAnnotation(DEResults_GSE42264)
DE_Results_GSE44331_GoodAnnotation <- FilteringDEResults_GoodAnnotation(DEResults_GSE44331)
DE_Results_GSE51365_GoodAnnotation <- FilteringDEResults_GoodAnnotation(DEResults_GSE51365)
DE_Results_GSE53784_GoodAnnotation <- FilteringDEResults_GoodAnnotation(DEResults_GSE53784)
DE_Results_GSE91074_GoodAnnotation <- FilteringDEResults_GoodAnnotation(DEResults_GSE91074)

# Check the structure of the DE results with good annotations 
# str(DE_Results_GSE30577_GoodAnnotation)
# str(DE_Results_GSE42264_GoodAnnotation)
# str(DE_Results_GSE44331_GoodAnnotation)
# str(DE_Results_GSE51365_GoodAnnotation)
# str(DE_Results_GSE53784_GoodAnnotation)
# str(DE_Results_GSE91074_GoodAnnotation)
```


### 7) Extraction of DE results for the contrasts of interest

```{r func_extract_contrastID}
# Create a function to extract the contrast ID from FC column names 
GetContrastIDsforResultSet <- function(NamesOfFoldChangeColumns){
  
  # Split the column names using the underscore as a delimiter
  # The result is a list where each element is a vector of the split parts of 
  # each column name
  ColumnNames_BrokenUp <- strsplit(NamesOfFoldChangeColumns, "_")
  
  # Convert the list of split names to a matrix
  MatrixOfColumnNames_BrokenUp <- do.call(rbind, ColumnNames_BrokenUp)
  
  # Extract the contrast IDs in the second column
  ContrastIDs_inCurrentDF <- MatrixOfColumnNames_BrokenUp[, 2]
  
  # Return the extracted contrast ID
  return(ContrastIDs_inCurrentDF)
}
```


```{r func_extract_contrast_DEResults}
# Create a function to extract DE results for contrasts of interest
ExtractingDEResultsForContrasts <- function(DE_Results_GoodAnnotation, 
                                            Contrasts_Log2FC, 
                                            Contrasts_Tstat, 
                                            ResultSet_contrasts){
  
    # Print the column names in the DE results with good annotations for the 
    # current ResultSet
    print("Columns in the DE results for the current ResultSet:")
    print(colnames(DE_Results_GoodAnnotation))
  
    # Print the column names that correspond to Log2FC values for contrasts of interest
    print("Columns of Log2FC for contrasts of interest within the DE results for the current ResultSet:")
    NamesOfFoldChangeColumns <- colnames(DE_Results_GoodAnnotation)[colnames(DE_Results_GoodAnnotation) %in% Contrasts_Log2FC]
    print(NamesOfFoldChangeColumns)
  
    # Print the column names that correspond to T-statistics values for contrasts of interest
    print("Columns of T-statistics for contrasts of interest within the DE results for the current ResultSet:")
    NamesOfTstatColumns <- colnames(DE_Results_GoodAnnotation)[colnames(DE_Results_GoodAnnotation) %in% Contrasts_Tstat]
    print(NamesOfTstatColumns)
  
    # Extract contrast IDs from FC column names using the function "GetContrastIDsforResultSet"
    ContrastIDs_inCurrentDF <- GetContrastIDsforResultSet(NamesOfFoldChangeColumns)
    print("Contrast IDs for contrasts of interest within the current ResultSet:")
    print(ContrastIDs_inCurrentDF)
  
    # Extract dataset IDs for contrasts of interest
    DatasetIDs <- ResultSet_contrasts$ExperimentID[ResultSet_contrasts$ContrastIDs %in% ContrastIDs_inCurrentDF]
    print("Dataset ID for the ResultSet and contrasts:")
    print(DatasetIDs)
  
    # Extract experimental factors for contrasts of interest
    Factors_inCurrentDF <- ResultSet_contrasts$ExperimentalFactors[ResultSet_contrasts$ContrastIDs %in% ContrastIDs_inCurrentDF]
    print("Experimental factors for ResultSet and contrasts:")
    print(Factors_inCurrentDF)
  
    # Combine dataset IDs and experimental factors to create unique identifiers 
    # for each statistical comparison
    ComparisonsOfInterest <- paste(DatasetIDs, Factors_inCurrentDF, sep = "_")
    print("Current names of contrasts of interest")
    print(ComparisonsOfInterest)
  
    # Create a list to store extracted DE results and relevant metadata
    DE_result_contrast <- list(
      All_Columns = colnames(DE_Results_GoodAnnotation),
      NamesOfFoldChangeColumns = NamesOfFoldChangeColumns,
      NamesOfTstatColumns = NamesOfTstatColumns,
      Contrast_ID = ContrastIDs_inCurrentDF,
      Dataset_ID = DatasetIDs,
      Experimental_Factor = Factors_inCurrentDF,
      ComparisonsOfInterest = ComparisonsOfInterest
  )
    # Return the list of all extracted info
    return(DE_result_contrast)
}
```


```{r func_extract_contrast_stat}
# Create a function to extract the Log2FC and T-statistics of contrast of interest
GetContrastStatColumns <- function(ResultSets_contrasts){
  
  # Extract the effect sizes (Log2FC) of contrasts of interest
  Contrasts_Log2FC <- paste("contrast_", ResultSets_contrasts$ContrastIDs, "_log2fc", sep = "")

  # Extract the T-statistics of contrasts of interest for calculating sampling variances
  Contrasts_Tstat <- paste("contrast_", ResultSets_contrasts$ContrastIDs, "_tstat", sep = "")

  # Create a dataframe to store the extracted information
  Contrasts_Stat <- data.frame(
    ExperimentID = ResultSets_contrasts$ExperimentIDs,
    ContrastID = ResultSets_contrasts$ContrastIDs,
    Log2FC_Column = Contrasts_Log2FC,
    Tstat_Column = Contrasts_Tstat,
    stringsAsFactors = FALSE
  )
  
  # Return the resulting dataframe
  return(Contrasts_Stat)
}
```


```{r run_extract_contrast_stat, cache = TRUE}
# Function use
Contrasts_Stat_Columns <- GetContrastStatColumns(ResultSets_contrasts)
```


```{r prep_contrast_stat, cache = TRUE}
# Prepare "Contrast_Log2FC" and "Contrast_Tstat" arguments for extracting DE results 
# of contrasts of interest

# GSE30577
Contrasts_Log2FC_GSE30577 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE30577") %>%
  pull(Log2FC_Column)

Contrasts_Tstat_GSE30577 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE30577") %>%
  pull(Tstat_Column)

# GSE42264 
Contrasts_Log2FC_GSE42264 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE42264") %>%
  pull(Log2FC_Column)

Contrasts_Tstat_GSE42264 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE42264") %>%
  pull(Tstat_Column)

# GSE44331
Contrasts_Log2FC_GSE44331 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE44331") %>%
  pull(Log2FC_Column)

Contrasts_Tstat_GSE44331 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE44331") %>%
  pull(Tstat_Column)

# GSE51365
Contrasts_Log2FC_GSE51365 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE51365") %>%
  pull(Log2FC_Column)

Contrasts_Tstat_GSE51365 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE51365") %>%
  pull(Tstat_Column)

# GSE53784
Contrasts_Log2FC_GSE53784 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE53784") %>%
  pull(Log2FC_Column)

Contrasts_Tstat_GSE53784 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE53784") %>%
  pull(Tstat_Column)

# GSE91074
Contrasts_Log2FC_GSE91074 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE91074") %>%
  pull(Log2FC_Column)

Contrasts_Tstat_GSE91074 <- Contrasts_Stat_Columns %>%
  filter(ExperimentID == "GSE91074") %>%
  pull(Tstat_Column)
```


```{r run_extract_contrast_DEResults, cache = TRUE}
# Function use

# GSE30577
DE_Results_Contrasts_GSE30577 <- ExtractingDEResultsForContrasts(DE_Results_GSE30577_GoodAnnotation,
                                                                 Contrasts_Log2FC_GSE30577,
                                                                 Contrasts_Tstat_GSE30577,
                                                                 ResultSets_contrasts)

# GSE42264
DE_Results_Contrasts_GSE42264 <- ExtractingDEResultsForContrasts(DE_Results_GSE42264_GoodAnnotation,
                                                                 Contrasts_Log2FC_GSE42264,
                                                                 Contrasts_Tstat_GSE42264,
                                                                 ResultSets_contrasts)

# GSE44331
DE_Results_Contrasts_GSE44331 <- ExtractingDEResultsForContrasts(DE_Results_GSE44331_GoodAnnotation,
                                                                 Contrasts_Log2FC_GSE44331,
                                                                 Contrasts_Tstat_GSE44331,
                                                                 ResultSets_contrasts)

# GSE51365
DE_Results_Contrasts_GSE51365 <- ExtractingDEResultsForContrasts(DE_Results_GSE51365_GoodAnnotation,
                                                                 Contrasts_Log2FC_GSE51365,
                                                                 Contrasts_Tstat_GSE51365,
                                                                 ResultSets_contrasts)

# GSE53784
DE_Results_Contrasts_GSE53784 <- ExtractingDEResultsForContrasts(DE_Results_GSE53784_GoodAnnotation,
                                                                 Contrasts_Log2FC_GSE53784,
                                                                 Contrasts_Tstat_GSE53784,
                                                                 ResultSets_contrasts)

# GSE91074
DE_Results_Contrasts_GSE91074 <- ExtractingDEResultsForContrasts(DE_Results_GSE91074_GoodAnnotation,
                                                                 Contrasts_Log2FC_GSE91074,
                                                                 Contrasts_Tstat_GSE91074,
                                                                 ResultSets_contrasts)
```


### 8) Collapse of DE results to one result per gene & Calculation of standard error
### and sampling variance

Gene expression can be measured using multiple probes (microarray). Therefore,
DE results need to be collapsed to one result per gene.

Standard error of Log2FC = Log2FC/T-statistics

Sampling variance = Average of standard error of each gene^2 


```{r func_collapse_contrast_DEResults}
# Create a function to average Log2FC, Tstat, standard error to one unique gene 
# per dataset 
CollapsingDEResults_OneResultPerGene<-function(GSE_ID, 
                                               DE_Results_GoodAnnotation, 
                                               ComparisonsOfInterest, 
                                               NamesOfFoldChangeColumns, 
                                               NamesOfTstatColumns){
  
  # Print a message to check if the vectors containing FC and T-stat column names 
  # are in the same order as the comparisons of interest
  print("Check if the vectors containing FC and Tstat column names contain the same order as the comparison of interest")
  
  # Print the number of unique NCBI IDs in the DE results
  print("# of rows with unique NCBI IDs:")
  print(length(unique(DE_Results_GoodAnnotation$NCBIid)))
  
  # Print the number of unique Gene Symbols in the DE results
  print("# of rows with unique Gene Symbols:")
  print(length(unique(DE_Results_GoodAnnotation$GeneSymbol)))
  
  # Create a folder named after the dataset ID to store results
  dir.create(paste("./", "Collapsing_DEResults_", GSE_ID, sep=""))
  
  # Set the working directory to the newly created folder
  setwd(paste("./", "Collapsing_DEResults_", GSE_ID, sep=""))
  
  # Create lists to store results
  DE_Results_GoodAnnotation_FoldChange_Average <- list()
  DE_Results_GoodAnnotation_Tstat_Average <- list()
  DE_Results_GoodAnnotation_SE_Average <- list()
  
  # Loop through each column containing FC and T-statistic info for the contrasts of interest
  for(i in c(1:length(NamesOfFoldChangeColumns))){
    
    # Select the Log2FC column of interest
    FoldChangeColumn <- dplyr::select(DE_Results_GoodAnnotation, NamesOfFoldChangeColumns[i])
    
    # Select the T-stat column of interest
    TstatColumn <- dplyr::select(DE_Results_GoodAnnotation, NamesOfTstatColumns[i])
    
    # Calculate the standard error (SE)
    DE_Results_GoodAnnotation_SE <- FoldChangeColumn[[1]]/TstatColumn[[1]]
    
    # Calculate the average Log2FC per gene
    DE_Results_GoodAnnotation_FoldChange_Average[[i]] <- tapply(FoldChangeColumn[[1]], 
                                                                DE_Results_GoodAnnotation$NCBIid, 
                                                                mean)
    
    # Calculate the average T-statistics per gene
    DE_Results_GoodAnnotation_Tstat_Average[[i]] <- tapply(TstatColumn[[1]], 
                                                           DE_Results_GoodAnnotation$NCBIid, 
                                                           mean)
    
    # Calculate the average SE per gene
    DE_Results_GoodAnnotation_SE_Average[[i]] <- tapply(DE_Results_GoodAnnotation_SE, 
                                                        DE_Results_GoodAnnotation$NCBIid, 
                                                        mean)
    
  }
  
  # Combine averaged Log2FC values into a single dataframe 
  DE_Results_GoodAnnotation_FoldChange_AveragedByGene <- do.call(cbind, DE_Results_GoodAnnotation_FoldChange_Average)
  
  # Print the dimensions of the averaged Fold Change matrix
  print("Dimensions of Fold Change matrix, averaged by gene symbol:")
  print(dim(DE_Results_GoodAnnotation_FoldChange_AveragedByGene))
  
  # Name the columns in the dataframe to describe the contrast of interest
  colnames(DE_Results_GoodAnnotation_FoldChange_AveragedByGene) <- ComparisonsOfInterest
  
  # Export the averaged Log2FC results into the working directory
  write.csv(DE_Results_GoodAnnotation_FoldChange_AveragedByGene, 
            paste("DEResults_", GSE_ID, "_GoodAnnotation_FoldChange_AveragedByGene.csv", sep = ""))
  
  # Combine T-statistics values into a single dataframe 
  DE_Results_GoodAnnotation_Tstat_AveragedByGene<-do.call(cbind, DE_Results_GoodAnnotation_Tstat_Average)
  
  # Name the columns in the dataframe to describe the contrast of interest
  colnames(DE_Results_GoodAnnotation_Tstat_AveragedByGene) <- ComparisonsOfInterest
  
  # Export the averaged T-statistics results into the working directory
  write.csv(DE_Results_GoodAnnotation_Tstat_AveragedByGene, 
            paste("DEResults_", GSE_ID, "_GoodAnnotation_Tstat_AveragedByGene.csv", sep = ""))
  
  # Combine SE values into a single dataframe 
  DE_Results_GoodAnnotation_SE_AveragedByGene<-do.call(cbind, DE_Results_GoodAnnotation_SE_Average)
  
  # Name the columns in the dataframe to describe the contrast of interest
  colnames(DE_Results_GoodAnnotation_SE_AveragedByGene) <- ComparisonsOfInterest
  
  # Export the averaged SE results into the working directory
  write.csv(DE_Results_GoodAnnotation_SE_AveragedByGene, 
            paste("DEResults_", GSE_ID, "_GoodAnnotation_SE_AveragedByGene.csv", sep = ""))
  
  # Calculate the sampling variance (SV) by squaring the SE
  DE_Results_GoodAnnotation_SV <- (DE_Results_GoodAnnotation_SE_AveragedByGene)^2
  
  # Export the SV results into the working directory
  write.csv(DE_Results_GoodAnnotation_SV, 
            paste("DEResults_", GSE_ID, "_GoodAnnotation_SV.csv", sep = ""))
  
  # Compile all averaged results into a single list 
  TempMasterResults<-list(Log2FC = DE_Results_GoodAnnotation_FoldChange_AveragedByGene,
                          Tstat = DE_Results_GoodAnnotation_Tstat_AveragedByGene, 
                          SE = DE_Results_GoodAnnotation_SE_AveragedByGene, 
                          SV = DE_Results_GoodAnnotation_SV)
  
  # Print the name of the output
  print(paste("Output: Collapsing_DEResults", GSE_ID, sep="_"))
  
  # Clean up the environment by removing temporary results
  rm(DE_Results_GoodAnnotation, DE_Results_GoodAnnotation_SV, 
     DE_Results_GoodAnnotation_SE, DE_Results_GoodAnnotation_FoldChange_AveragedByGene,
     DE_Results_GoodAnnotation_FoldChange_Average, DE_Results_GoodAnnotation_Tstat_AveragedByGene,
     DE_Results_GoodAnnotation_Tstat_Average, DE_Results_GoodAnnotation_SE_Average, 
     FoldChangeColumn, TstatColumn, GSE_ID, ComparisonsOfInterest, NamesOfFoldChangeColumns, 
     NamesOfTstatColumns)
  
  # Set the working directory back to the parent directory
  setwd("../")
  
  # Return the compiled results
  return(TempMasterResults)
}
```


```{r prep_col_name, cache = TRUE}
# Prepare "NamesOfFoldChangeColumns" and "NamesOfTstatColumns" arguments for  
# extracting DE results of contrasts of interest

# GSE30577
NamesOfFoldChangeColumns_GSE30577 <- DE_Results_Contrasts_GSE30577[[2]]
NamesOfTstatColumns_GSE30577 <- DE_Results_Contrasts_GSE30577[[3]]
ComparisonsOfInterest_GSE30577 <- c("GSE30577_Rabies_vs_Control")

# GSE42264
NamesOfFoldChangeColumns_GSE42264 <- DE_Results_Contrasts_GSE42264[[2]]
NamesOfTstatColumns_GSE42264 <- DE_Results_Contrasts_GSE42264[[3]]
ComparisonsOfInterest_GSE42264 <- c("GSE42264_Measles_vs_Control")

# GSE44331
NamesOfFoldChangeColumns_GSE44331 <- DE_Results_Contrasts_GSE44331[[2]]
NamesOfTstatColumns_GSE44331 <- DE_Results_Contrasts_GSE44331[[3]]
ComparisonsOfInterest_GSE44331 <- c("GSE44331_VSV_vs_Control")

# GSE51365
NamesOfFoldChangeColumns_GSE51365 <- DE_Results_Contrasts_GSE51365[[2]]
NamesOfTstatColumns_GSE51365 <- DE_Results_Contrasts_GSE51365[[3]]
ComparisonsOfInterest_GSE51365 <- c("GSE51365_MVH68_WT_vs_Control", "GSE51365_MVH68_M_vs_Control")

# GSE53784
NamesOfFoldChangeColumns_GSE53784 <- DE_Results_Contrasts_GSE53784[[2]]
NamesOfTstatColumns_GSE53784 <- DE_Results_Contrasts_GSE53784[[3]]
ComparisonsOfInterest_GSE53784 <- c("GSE53784_WNV_vs_Control", "GSE53784_JEV_vs_Control")

# GSE91074
NamesOfFoldChangeColumns_GSE91074 <- DE_Results_Contrasts_GSE91074[[2]]
NamesOfTstatColumns_GSE91074 <- DE_Results_Contrasts_GSE91074[[3]]
ComparisonsOfInterest_GSE91074 <- c("GSE91074_VEEV_vs_Control")
```


```{r run_collapse_contrast_DEResults, cache = TRUE}
# Function use

# GSE30577
Collapsing_DEResults_GSE30577 <- CollapsingDEResults_OneResultPerGene("GSE30577",
                                                                      DE_Results_GSE30577_GoodAnnotation,
                                                                      ComparisonsOfInterest_GSE30577,
                                                                      NamesOfFoldChangeColumns_GSE30577,
                                                                      NamesOfTstatColumns_GSE30577)

# GSE42264
Collapsing_DEResults_GSE42264 <- CollapsingDEResults_OneResultPerGene("GSE42264",
                                                                      DE_Results_GSE42264_GoodAnnotation,
                                                                      ComparisonsOfInterest_GSE42264,
                                                                      NamesOfFoldChangeColumns_GSE42264,
                                                                      NamesOfTstatColumns_GSE42264)

# GSE44331
Collapsing_DEResults_GSE44331 <- CollapsingDEResults_OneResultPerGene("GSE44331",
                                                                      DE_Results_GSE44331_GoodAnnotation,
                                                                      ComparisonsOfInterest_GSE44331,
                                                                      NamesOfFoldChangeColumns_GSE44331,
                                                                      NamesOfTstatColumns_GSE44331)

# GSE51365
Collapsing_DEResults_GSE51365 <- CollapsingDEResults_OneResultPerGene("GSE51365",
                                                                      DE_Results_GSE51365_GoodAnnotation,
                                                                      ComparisonsOfInterest_GSE51365,
                                                                      NamesOfFoldChangeColumns_GSE51365,
                                                                      NamesOfTstatColumns_GSE51365)

# GSE53784
Collapsing_DEResults_GSE53784 <- CollapsingDEResults_OneResultPerGene("GSE53784",
                                                                      DE_Results_GSE53784_GoodAnnotation,
                                                                      ComparisonsOfInterest_GSE53784,
                                                                      NamesOfFoldChangeColumns_GSE53784,
                                                                      NamesOfTstatColumns_GSE53784)

# GSE91074
Collapsing_DEResults_GSE91074 <- CollapsingDEResults_OneResultPerGene("GSE91074",
                                                                      DE_Results_GSE91074_GoodAnnotation,
                                                                      ComparisonsOfInterest_GSE91074,
                                                                      NamesOfFoldChangeColumns_GSE91074,
                                                                      NamesOfTstatColumns_GSE91074)
```


### 9) Alignment of DE results from same models (mouse & rat)

Each dataset has DE results from a slightly different list of genes.

Depending on the exact tissue dissected, the sensitivity of the transcriptional 
profiling platform, the representation on the transcriptional profiling platform 
(for microarray), and the experimental conditions, the DE results from different 
datasets will also be in a slightly different order.

We want to align these results so that the DE results from each dataset are columns, 
with each row representing a different gene.

- GSE30577 - Mouse model

- GSE42264 - Mouse model

- GSE44331 - Mouse model

- GSE51365 - Mouse model

- GSE53784 - Mouse model

- GSE91074 - Mouse model

Since there are only mouse models, we would create one aligning function.
If there are both mouse and rat models, we would have to create two aligning 
functions, one for the mouse and one for the rat.

```{r func_align_same}
# Create a function to align all mouse DE results from different datasets into
# a single dataframe for Log2FC and SV
AligningMouseDatasets <- function(ListOfMouseDEResults){
  
  # Create a list to store the log2FC 
  Mouse_MetaAnalysis_FoldChange_Dfs <- list()
  
  # Loop through all mouse DE results
  for(i in c(1:length(ListOfMouseDEResults))){

    # Extract the Log2FC values from each dataset and put them into separate list
    # The element from the "Collapsing_DEResults_" has the format of row names
    # as Entrez Gene ID and columns containing Log2FC values
    Mouse_MetaAnalysis_FoldChange_Dfs[[i]] <- data.frame(Mouse_EntrezGene.ID = row.names(ListOfMouseDEResults[[i]][[1]]),
                                                         ListOfMouseDEResults[[i]][[1]], 
                                                         stringsAsFactors = FALSE)
  }
  
  # Print the structure of the Log2FC lists
  print("Mouse_MetaAnalysis_FoldChange_Dfs:")
  print(str(Mouse_MetaAnalysis_FoldChange_Dfs))
  
  # ALign the DE results by Entrez Gene ID and turn them into a single dataframe
  # join_all can be used for object of list class
  Mouse_MetaAnalysis_FoldChanges <<- join_all(Mouse_MetaAnalysis_FoldChange_Dfs, 
                                              by = "Mouse_EntrezGene.ID", 
                                              type = "full")

  # Print the structure of the aligned Log2FC 
  print("Mouse_MetaAnalysis_FoldChanges:")
  print(str(Mouse_MetaAnalysis_FoldChanges))
  
  # Create a list to store the SV 
  Mouse_MetaAnalysis_SV_Dfs <- list()
  
  # Loop through all mouse DE results 
  for(i in c(1:length(ListOfMouseDEResults))){
    
    # Extract the SV values from each dataset and put them into separate list
    # The element from the "Collapsing_DEResults_" has the format of row names
    # as Entrez Gene ID and columns containing SV values
    Mouse_MetaAnalysis_SV_Dfs[[i]] <- data.frame(Mouse_EntrezGene.ID = row.names(ListOfMouseDEResults[[i]][[4]]),
                                                 ListOfMouseDEResults[[i]][[4]], 
                                                 stringsAsFactors = FALSE)
  }
  
  # Print the structure of the SV lists
  print("Mouse_MetaAnalysis_SV_Dfs:")
  print(str(Mouse_MetaAnalysis_SV_Dfs))
  
  # ALign the DE results by Entrez Gene ID and turn them into a single dataframe
  # join_all can be used for object of list class
  Mouse_MetaAnalysis_SV <<- join_all(Mouse_MetaAnalysis_SV_Dfs, 
                                     by = "Mouse_EntrezGene.ID",
                                     type = "full")

  # Print the structure of the aligned SV 
  print("Mouse_MetaAnalysis_SV:")
  print(str(Mouse_MetaAnalysis_SV))
  
  # Remove the temporary lists of Log2FC and SV
  rm(Mouse_MetaAnalysis_SV_Dfs, Mouse_MetaAnalysis_FoldChange_Dfs)
}
```


```{r run_align_same, cache = TRUE}
# Prepare the list of collapsed mouse DE results
ListOfMouseDEResults <- list(Collapsing_DEResults_GSE30577, 
                             Collapsing_DEResults_GSE42264,
                             Collapsing_DEResults_GSE44331, 
                             Collapsing_DEResults_GSE51365,
                             Collapsing_DEResults_GSE53784, 
                             Collapsing_DEResults_GSE91074)

# Function use
AligningMouseDatasets(ListOfMouseDEResults)
```


### 10) Alignment of DE results from different models (mouse & rat)

#### Concept of *Gene Orthologs*:

- *Homology* refers to biological features including genes and their products that 
are descended from a feature present in a common ancestor.

- *Homologous gene* become separated in evolution in 2 different ways:

1. Separation of 2 populations with the ancestral gene into 2 species. Gene separated 
by *speciation* are called *orthologs*.

2. Duplication of the ancestral gene within a lineage. Gene separated by *gene duplication* 
are called *paralogs*.

Ref: https://www.nlm.nih.gov/ncbi/workshops/2023-08_BLAST_evol/ortho_para.html

We have the ortholog database that we downloaded from Jackson Lab on April 25, 2024.
This database was trimmed and formatted using "FormattingRatMouseOrthologDatabase_20240425.R"

```{r join_database, cache = TRUE}
# Import the trimmed and formatted ortholog database
MouseVsRat_NCBI_Entrez <- read.csv("MouseVsRat_NCBI_Entrez_JacksonLab_20240425.csv",
                                   header = TRUE,
                                   stringsAsFactors = FALSE,
                                   row.names = 1,
                                   colClasses = c("character", "character", "character"))

# Join the ortholog database with mouse Log2FC

#### Problem arise here with the NA in the orthologs
Mouse_MetaAnalysis_FoldChanges_wOrthologs <- join(MouseVsRat_NCBI_Entrez, 
                                                  Mouse_MetaAnalysis_FoldChanges,
                                                  by = "Mouse_EntrezGene.ID",
                                                  type = "full")

# Join the ortholog database with mouse SV
Mouse_MetaAnalysis_SV_wOrthologs <- join(MouseVsRat_NCBI_Entrez,
                                         Mouse_MetaAnalysis_SV,
                                         by = "Mouse_EntrezGene.ID",
                                         type = "full")

# Check the structure of the new mouse Log2FC with ortholog info
str(Mouse_MetaAnalysis_FoldChanges_wOrthologs)

# Check the structure of the new mouse SV with ortholog info
str(Mouse_MetaAnalysis_SV_wOrthologs)
```


```{r join_orthologs_rat, eval = FALSE}
# If there are rat datasets, we want to join our mouse Log2FC and SV results to 
# the rat Log2FC and SV results using the ortholog info

# Join the Log2FC of the mouse datasets and rat datasets
MetaAnalysis_FoldChanges <- join(Mouse_MetaAnalysis_FoldChanges_wOrthologs,
                                 Rat_MetaAnalysis_FoldChanges,
                                 by = "Rat_EntrezGene.ID",
                                 type = "full")

# Check the structure of the joined mouse and rat Log2FC with ortholog info
str(MetaAnalysis_FoldChanges)
 
# Join the SV of the mouse datasets and rat datasets
MetaAnalysis_SV <- join(Mouse_MetaAnalysis_SV_wOrthologs,
                        Rat_MetaAnalysis_FoldChanges,
                        by = "Rat_EntrezGene.ID",
                        type = "full")

# Check the structure of the joined mouse and rat SV with ortholog info
str(MetaAnalysis_SV)
```


```{r join_orthologs_norat}
# If there are no rat dataset, we rename the dataframes so the pipeline code works
MetaAnalysis_FoldChanges <- Mouse_MetaAnalysis_FoldChanges_wOrthologs
MetaAnalysis_SV <- Mouse_MetaAnalysis_SV_wOrthologs

# Rename Mouse_Rat Entrez annotation for Log2FC dataframe
MetaAnalysis_FoldChanges$MouseVsRat_EntrezGene.ID <- paste(MetaAnalysis_FoldChanges$Mouse_EntrezGene.ID,
                                                           MetaAnalysis_FoldChanges$Rat_EntrezGene.ID, 
                                                           sep="_")

# Rename Mouse_Rat Entrez annotation for SV dataframe
MetaAnalysis_SV$MouseVsRat_EntrezGene.ID <- paste(MetaAnalysis_SV$Mouse_EntrezGene.ID, 
                                                  MetaAnalysis_SV$Rat_EntrezGene.ID, 
                                                  sep="_")

# Check the structure of the Log2FC dataframe
str(MetaAnalysis_FoldChanges)

# Check the structure of the SV dataframe 
str(MetaAnalysis_SV)
```


### 11) Comparison of Log2FC across datasets

```{r col_names_meta}
# Check the column names in the MetaAnalysis dataframes
colnames(MetaAnalysis_FoldChanges)
```

There are different ways to plot relationships across datasets:

1. Rank-rank hypergeometric overlap plots 

2. Hierarchically clustered heatmaps

We can generally compare the DE results associated with different contrasts 
using a scatter plot and correlation analysis.

```{r cor_matrix, cache = TRUE}
# Create a correlation matrix for Log2FC across datasets
# "pairwise.complete.obs" ignore any rows of DE results that do not have Log2FC 
# for one of our columns
MetaAnalysis_CorMatrix_FoldChanges <- cor(as.matrix(MetaAnalysis_FoldChanges[,-c(1:3)]), 
                                                    use = "pairwise.complete.obs",
                                                    method = "spearman")
# Check the correlation matrix
MetaAnalysis_CorMatrix_FoldChanges
```

Each cell includes the correlation coefficient reflecting the similarity of the 
effect sizes for the comparison of between the contrast in the row and the according
contrast in the column.

Correlation coefficient ranges between -1 to 1, with -1 being a perfect negative 
correlation and +1 being a perfect positive correlation

```{r heatmap, cache = TRUE}
# Illustrate the correlation matrix with hierarchically clustered heatmap

# Blues Palette
# png("MetaAnalysis_CorMatrix_FoldChanges_1.png", 8, 5, "in", res = 300)
pheatmap(MetaAnalysis_CorMatrix_FoldChanges,
         display_numbers = TRUE,
         fontsize = 10,
         number_format = "%.2f", 
         color = colorRampPalette(brewer.pal(5, "Blues"))(100),
         border_color = "black",
         number_color = "black")
# dev.off()

# Oranges Palette
# png("MetaAnalysis_CorMatrix_FoldChanges_2.png", 8, 5, "in", res = 300)
pheatmap(MetaAnalysis_CorMatrix_FoldChanges,
         display_numbers = TRUE,
         fontsize = 10,
         number_format = "%.2f", 
         color = colorRampPalette(brewer.pal(5, "Oranges"))(100),
         border_color = "black",
         number_color = "black")
# dev.off()

# Blues-Yellows Palette
# png("MetaAnalysis_CorMatrix_FoldChanges_3.png", 8, 5, "in", res = 300)
pheatmap(MetaAnalysis_CorMatrix_FoldChanges,
         display_numbers = TRUE,
         fontsize = 10,
         number_format = "%.2f", 
         color = hcl.colors(5, "BluYl"),
         border_color = "black",
         number_color = "black")
# dev.off()

# Viridis Palette
# png("MetaAnalysis_CorMatrix_FoldChanges_4.png", 8, 5, "in", res = 300)
pheatmap(MetaAnalysis_CorMatrix_FoldChanges,
         display_numbers = TRUE,
         fontsize = 10,
         number_format = "%.2f", 
         color = viridis(5),
         border_color = "black",
         number_color = "black")
# dev.off()

# The groups are placed in order by similarity, as determined by hierarchical clustering
# The lines ("tree branches") on the left and top illustrate that similarity (clustering) 
# using a "dendrogram"
```


### 12) Meta-analysis with random effect models

The meta-analysis is performed using the effect sizes (Log2FC) and sampling variances
(SV) for each gene stored in the objects *MetaAnalysis_FoldChanges* and *MetaAnalysis_SV*.

For any particular gene, it is likely that some datasets may be missing DE results.
This is especially true for genes that have low levels of expression and may not 
be detected by less sensitive assays. It is also likely to be true for genes that 
were discovered more recently (i.e., not targeted by older microarray platforms)
or that lack a clear ortholog in rat/mouse.

We can only run a meta-analysis if there DE results from more than 1 statistical
contrast. Since the DE results from the same study (dataset) are often artificially
correlated (especially if they use the same control group as the comparison), we 
would prefer that there are results from more than 1 dataset (not just more than
1 statistical contrast)

Before the meta-analysis, we need to decide the minimum number of DE results allowed
for a gene to be included.

```{r cal_NA_meta, cache = TRUE}
# Calculate the number of NAs (the number of statistical contrasts lacking DE
# results) in each row (for each gene)
MetaAnalysis_FoldChanges_NAsPerRow <- apply(MetaAnalysis_FoldChanges[,-c(1:3)], 
                                            1, 
                                            function(y) sum(is.na(y)))

# Visualize the distribution of the NAs with histogram
hist(MetaAnalysis_FoldChanges_NAsPerRow)

# Viusalize the distribution of the NAs with table 
table(MetaAnalysis_FoldChanges_NAsPerRow)

# This table tells us how many genes (rows) contain each number of NAs 
# Ex: There are 9979 genes that contain no NA, meaning that these 9979 genes can 
# be found across all datasets
# Ex: There are 5767 genes that contain 1 NA in 1 of the 8 contrasts
```


```{r func_meta}
# Create a function to run the meta-analysis
RunBasicMetaAnalysis <- function(NumberofComparisons,
                                 CutOffForNAs,
                                 MetaAnalysis_FoldChanges,
                                 MetaAnalysis_SV){
  
  # Calculate the number of NAs (the number of statistical contrasts lacking DE
  # results) in each row (for each gene)
  MetaAnalysis_FoldChanges_NAsPerRow <- apply(MetaAnalysis_FoldChanges[,-c(1:3)], 
                                              1, 
                                              function(y) sum(is.na(y)))
  
  # Print the number of NAs per gene
  print("Table of # of NAs per Row (Gene):")
  print(table(MetaAnalysis_FoldChanges_NAsPerRow))
  
  # Filter the genes with too many NAs
  MetaAnalysis_FoldChanges_ForMeta <- MetaAnalysis_FoldChanges[MetaAnalysis_FoldChanges_NAsPerRow < CutOffForNAs,]
  MetaAnalysis_SV_ForMeta <- MetaAnalysis_SV[MetaAnalysis_FoldChanges_NAsPerRow < CutOffForNAs,]
  
  # Print the structure of the filtered FC
  print("MetaAnalysis_FoldChanges_ForMeta:")
  print(str(MetaAnalysis_FoldChanges_ForMeta))
  
  # Print the structure of the filtered SV
  print("MetaAnalysis_SV_ForMeta:")
  print(str(MetaAnalysis_SV_ForMeta))
  
  # Create a matrix with 6 columns filled with NAs to store the meta-analysis results
  metaOutput <- matrix(NA, nrow(MetaAnalysis_FoldChanges_ForMeta), 6)
  
  # Loop through each gene to perform meta-analysis
  for(i in c(1:nrow(MetaAnalysis_FoldChanges_ForMeta))){
    
    # Extract the Log2FC and SV value for the current gene in numeric format
    # Remove the annotation columns prior to extraction
    fc <- as.numeric(MetaAnalysis_FoldChanges_ForMeta[i, -c(1:3)])
    sv <- as.numeric(MetaAnalysis_SV_ForMeta[i, -c(1:3)])
    
    # Perform meta-analysis using random-effect model that treat Log2FC across 
    # studies as random effects
    
    # Set the flag as FALSE 
    # This flag is used to determine if the current iteration should be skipped
    # due to an error
    skip_to_next <- FALSE
    
    # The "tryCatch" function will execute the code within "{}" block. If an error
    # occurs, the code in the "error" block is executed
    tryCatch({
      # Perform meta-analysis that treat Log2FC across studies as random effects
      TempMeta <- rma(fc, sv)
      # Store estimated Log2FC
      metaOutput[i,1] <- TempMeta$b
      # Store standard error of estimate
      metaOutput[i,2] <- TempMeta$se
      # Store p-value
      metaOutput[i,3] <- TempMeta$pval
      # Store lower bound of the confidence interval
      metaOutput[i,4] <- TempMeta$ci.lb
      # Store the upper bound of the confidence interval
      metaOutput[i,5] <- TempMeta$ci.ub
      # Store the number of comparisons with available data
      metaOutput[i,6] <- NumberOfComparisons-sum(is.na(fc))
    },
      # If an error occurs during the meta-analysis, the "error" function sets
      # "skip_to_next" to TRUE
      error = function(e){skip_to_next <<- TRUE})
    
    # If "skip_to_next" is TRUE, the "next" statement skips the current iteration
    # and move to the next gene 
    if(skip_to_next) next
    
    # Remove temporary variables
    rm(fc, sv)
  } 
  
  # Name the columns in the output
  colnames(metaOutput) <- c("Log2FC_estimate", 
                            "SE", 
                            "pval", 
                            "CI_lb", 
                            "CI_ub", 
                            "Number_Of_Comparisons")
  
  # Assign the combined mouse-rat entrez ID as row names of the output 
  row.names(metaOutput) <- MetaAnalysis_FoldChanges_ForMeta[,3]
  
  # Print the structure of the output
  print("metaOutput:")
  print(str(metaOutput))
  
  # Print the top of the output 
  print("Top of metaOutput:")
  print(head(metaOutput))
  
  # Print the bottom of the output 
  print("Bottom of metaOutput:")
  print(tail(metaOutput))
  
  # Change the format of the output to dataframe for the final list
  metaOutput <- as.data.frame(metaOutput)
  
  # Return the output and the annotation as separated lists
  return(list(metaOutput = metaOutput, 
              MetaAnalysis_Annotation = MetaAnalysis_FoldChanges_ForMeta[, c(1:3)],
              MetaAnalysis_FoldChanges_ForMeta = MetaAnalysis_FoldChanges_ForMeta,
              MetaAnalysis_SV_ForMeta = MetaAnalysis_SV_ForMeta))
}
```


```{r run_meta, cache = TRUE}
# Set up number of comparisons and cut off for NAs
# The number of NA = CutOffForNAs - 1
# Ex: 0 NA => CutOffForNA = 1
# Ex: 1 NA => CutOffForNA = 2

# There are 8 contrasts and we want genes that are available in all 8 contrasts
NumberOfComparisons = 8
CutOffForNAs = 1

# Function use 
# Meta-analysis with 0 NA
MetaAnalysis_Results_0NA <- suppressWarnings(
  RunBasicMetaAnalysis(NumberOfComparisons,
                       CutOffForNAs,
                       MetaAnalysis_FoldChanges,
                       MetaAnalysis_SV)
)

# Separate the meta-analysis output and annotation 
# 0 NA
metaOutput_0NA <- MetaAnalysis_Results_0NA[[1]]
MetaAnalysis_Annotation_0NA <- MetaAnalysis_Results_0NA[[2]]
MetaAnalysis_FoldChanges_ForMeta_0NA <- MetaAnalysis_Results_0NA[[3]]
MetaAnalysis_SV_ForMeta_0NA <- MetaAnalysis_Results_0NA[[4]]
```


### 13) Correction of p-value using Benjamini-Hochberg method

```{r join_database_2}
# Import database containing more detailed gene annotation
HOM_MouseVsRat <- read.csv("HOM_MouseVsRat_20240425.csv", header = TRUE, row.names = 1)

# Check the names of the columns of the database 
colnames(HOM_MouseVsRat)

# Change the format of the column names to character
HOM_MouseVsRat$Mouse_EntrezGene.ID <- as.character(HOM_MouseVsRat$Mouse_EntrezGene.ID)
HOM_MouseVsRat$Rat_EntrezGene.ID <- as.character(HOM_MouseVsRat$Rat_EntrezGene.ID)
```


```{r func_FDR}
# Create a function to correct FDR and extract genes with certain threshold of FDR
# and Log2FC
FalseDiscoveryCorrection <- function(NumberOfNAs,
                                     metaOutput,
                                     HOM_MouseVsRat,
                                     MetaAnalysis_Annotation){
  
  # Calculate the FDR (q-value) for each p-value using the Benjamini-Hochberg method
  tempPvalAdjMeta <- mt.rawp2adjp(metaOutput[, 3], proc = c("BH"))
  
  # Re-order the FDR to match with the original order 
  metaPvalAdj <- tempPvalAdjMeta$adjp[order(tempPvalAdjMeta$index), ]
  
  # Add the FDR column to the meta-analysis output
  metaOutputFDR <- cbind(metaOutput, FDR = metaPvalAdj[, 2])
  
  # Rename the column to "FDR"
  colnames(metaOutputFDR)[7] <- "FDR"
  
  # Print the structure of meta-analysis output with FDR
  print("Meta-analysis output with FDR:")
  print(str(metaOutputFDR))
  
  # Add annotations to the output
  TempDF <- cbind(metaOutputFDR, MetaAnalysis_Annotation)
  
  # Add detailed gene annotations for mouse genes
  TempDF2 <- join(TempDF, 
                  HOM_MouseVsRat[, c(4:5, 9:11)], 
                  by = "Mouse_EntrezGene.ID", 
                  type = "left",
                  match = "first")
  
  # Add detailed gene annotations for rat genes
  TempDF3 <- join(TempDF2, 
                  HOM_MouseVsRat[, c(15:16, 20:22)], 
                  by = "Rat_EntrezGene.ID",
                  type = "left",
                  match = "first")
  
  # Save the annotated results to the meta-analysis output 
  metaOutputFDR_annotated <- TempDF3
  
  # Export the annotated meta-analysis output into the working directory 
  # (remove the row names as entrez ID have been merged into the dataframe)
  write.csv(metaOutputFDR_annotated, 
            paste("metaOutputFDR_Annotated_", NumberOfNAs, "NA.csv", sep = ""), 
            row.names = FALSE)
  
  # Order the results by p-value 
  # The results are ordered by p-values because close p-values can result in the same
  # FDR due to the restriction of the algorithm (the bending of FDR)
  metaOutputFDR_OrderbyPval <- metaOutputFDR_annotated[order(metaOutputFDR_annotated$pval), ]
  
  # Filter the ordered results by Log2FC threshold at 2
  metaOutputFDR_OrderbyPval_Log2FC_2 <- metaOutputFDR_annotated %>%
    filter(abs(Log2FC_estimate) >= 2) %>%
    arrange(pval)
  
  # Filter the ordered results by Log2FC threshold at 1
  metaOutputFDR_OrderbyPval_Log2FC_1 <- metaOutputFDR_annotated %>%
    filter(abs(Log2FC_estimate) >= 1) %>%
    arrange(pval)
  
  # Filter the ordered results by Log2FC threshold at 0.5
  metaOutputFDR_OrderbyPval_Log2FC_0.5 <- metaOutputFDR_annotated %>%
    filter(abs(Log2FC_estimate) >= 0.5) %>%
    arrange(pval)
  
  # Export the ordered, annotated meta-analysis output into the working directory 
  # (remove the row names as entrez ID have been merged into the dataframe)
  write.csv(metaOutputFDR_OrderbyPval, 
            paste("metaOutputFDR_OrderedByPval_", NumberOfNAs, "NA.csv",sep = ""), 
            row.names = FALSE)
  
  # Export the ordered, annotated, filtered results at Log2FC of 2
  write.csv(metaOutputFDR_OrderbyPval_Log2FC_2, 
            paste("metaOutputFDR_OrderedByPval_Log2FC_2_", NumberOfNAs, "NA.csv",sep = ""), 
            row.names = FALSE)
  
  # Export the ordered, annotated, filtered results at Log2FC of 1
  write.csv(metaOutputFDR_OrderbyPval_Log2FC_1, 
            paste("metaOutputFDR_OrderedByPval_Log2FC_1_", NumberOfNAs, "NA.csv",sep = ""), 
            row.names = FALSE)
  
  # Export the ordered, annotated, filtered results at Log2FC of 0.5
  write.csv(metaOutputFDR_OrderbyPval_Log2FC_0.5, 
            paste("metaOutputFDR_OrderedByPval_Log2FC_0.5_", NumberOfNAs, "NA.csv",sep = ""), 
            row.names = FALSE)
  
  # Print genes with FDR < 0.1 
  print("# of genes that are statistically significant following loose FDR correction (FDR < 0.10):")
  print(sum(metaOutputFDR_annotated$FDR < 0.10, na.rm = TRUE))
  
  print("# of upregulated genes that are statistically significant following loose FDR correction (FDR < 0.10):")
  print(sum(metaOutputFDR_annotated$FDR < 0.10 & metaOutputFDR_annotated$Log2FC_estimate > 0, na.rm = TRUE))
  
  print("# of downregulated genes that are statistically significant following loose FDR correction (FDR < 0.10):")
  print(sum(metaOutputFDR_annotated$FDR < 0.10 & metaOutputFDR_annotated$Log2FC_estimate < 0, na.rm = TRUE))
  
  # Print genes with FDR < 0.05
  print("# of genes that are statistically significant following traditional FDR correction (FDR < 0.05):")
  print(sum(metaOutputFDR_annotated$FDR < 0.05, na.rm = TRUE))
  
  print("# of upregulated genes that are statistically significant following traditional FDR correction (FDR < 0.05):")
  print(sum(metaOutputFDR_annotated$FDR < 0.05 & metaOutputFDR_annotated$Log2FC_estimate > 0, na.rm = TRUE))
  
  print("# of downregulated genes that are statistically significant following traditional FDR correction (FDR < 0.05):")
  print(sum(metaOutputFDR_annotated$FDR < 0.05 & metaOutputFDR_annotated$Log2FC_estimate < 0, na.rm = TRUE))
  
  print("# of genes that are statistically significant following traditional FDR correction (FDR < 0.05) and |Log2FC|  2:")
  print(sum(metaOutputFDR_OrderbyPval_Log2FC_2$FDR < 0.05, na.rm = TRUE))
  
  print("# of upregulated genes that are statistically significant following traditional FDR correction (FDR < 0.05) and |Log2FC|  2:")
  print(sum(metaOutputFDR_OrderbyPval_Log2FC_2$FDR < 0.05 & metaOutputFDR_OrderbyPval_Log2FC_2$Log2FC_estimate > 0, na.rm = TRUE))
  
  print("# of downregulated genes that are statistically significant following traditional FDR correction (FDR < 0.05) and |Log2FC|  2:")
  print(sum(metaOutputFDR_OrderbyPval_Log2FC_2$FDR < 0.05 & metaOutputFDR_OrderbyPval_Log2FC_2$Log2FC_estimate < 0, na.rm = TRUE))
  
  print("# of genes that are statistically significant following traditional FDR correction (FDR < 0.05) and |Log2FC|  1:")
  print(sum(metaOutputFDR_OrderbyPval_Log2FC_1$FDR < 0.05, na.rm = TRUE))
  
  print("# of upregulated genes that are statistically significant following traditional FDR correction (FDR < 0.05) and |Log2FC|  1:")
  print(sum(metaOutputFDR_OrderbyPval_Log2FC_1$FDR < 0.05 & metaOutputFDR_OrderbyPval_Log2FC_1$Log2FC_estimate > 0, na.rm = TRUE))
  
  print("# of downregulated genes that are statistically significant following traditional FDR correction (FDR < 0.05) and |Log2FC|  1:")
  print(sum(metaOutputFDR_OrderbyPval_Log2FC_1$FDR < 0.05 & metaOutputFDR_OrderbyPval_Log2FC_1$Log2FC_estimate < 0, na.rm = TRUE))
  
  print("# of genes that are statistically significant following traditional FDR correction (FDR < 0.05) and |Log2FC|  0.5:")
  print(sum(metaOutputFDR_OrderbyPval_Log2FC_0.5$FDR < 0.05, na.rm = TRUE))
  
  print("# of upregulated genes that are statistically significant following traditional FDR correction (FDR < 0.05) and |Log2FC|  0.5:")
  print(sum(metaOutputFDR_OrderbyPval_Log2FC_0.5$FDR < 0.05 & metaOutputFDR_OrderbyPval_Log2FC_0.5$Log2FC_estimate > 0, na.rm = TRUE))
  
  print("# of downregulated genes that are statistically significant following traditional FDR correction (FDR < 0.05) and |Log2FC|  0.5:")
  print(sum(metaOutputFDR_OrderbyPval_Log2FC_0.5$FDR < 0.05 & metaOutputFDR_OrderbyPval_Log2FC_0.5$Log2FC_estimate < 0, na.rm = TRUE))
  
  # Print top results in mouse genes
  print("Top 20 results ordered by p-values in mouse genes:")
  print(head(metaOutputFDR_OrderbyPval$Mouse_Symbol, 20))
  
  # Print top results in rat genes
  print("Top 20 results ordered by p-values in rat genes:")
  print(head(metaOutputFDR_OrderbyPval$Rat_Symbol, 20))
  
  # Print top results in mouse genes with |Log2FC| >= 2
  print("Top 20 results ordered by p-values in mouse genes with |Log2FC| >= 2:")
  print(head(metaOutputFDR_OrderbyPval_Log2FC_2$Mouse_Symbol, 20))
  
  # Print top results in rat genes with |Log2FC| >= 2
  print("Top 20 results ordered by p-values in rat genes with |Log2FC| >= 2:")
  print(head(metaOutputFDR_OrderbyPval_Log2FC_2$Rat_Symbol, 20))
  
  # Print top results in mouse genes with |Log2FC| >= 1
  print("Top 20 results ordered by p-values in mouse genes with |Log2FC| >= 1:")
  print(head(metaOutputFDR_OrderbyPval_Log2FC_1$Mouse_Symbol, 20))
  
  # Print top results in rat genes with |Log2FC| >= 1
  print("Top 20 results ordered by p-values in rat genes with |Log2FC| >= 1:")
  print(head(metaOutputFDR_OrderbyPval_Log2FC_1$Rat_Symbol, 20))
  
  # Print top results in mouse genes with |Log2FC| >= 0.5
  print("Top 20 results ordered by p-values in mouse genes with |Log2FC| >= 0.5:")
  print(head(metaOutputFDR_OrderbyPval_Log2FC_0.5$Mouse_Symbol, 20))
  
  # Print top results in rat genes with |Log2FC| >= 0.5
  print("Top 20 results ordered by p-values in rat genes with |Log2FC| >= 0.5:")
  print(head(metaOutputFDR_OrderbyPval_Log2FC_0.5$Rat_Symbol, 20))
  
  
  # Return the annotated output and ordered output with FDR 
  return(list(metaOutputFDR = metaOutputFDR,
              metaOutputFDR_annotated = metaOutputFDR_annotated,
              metaOutputFDR_OrderbyPval = metaOutputFDR_OrderbyPval,
              metaOutputFDR_OrderbyPval_Log2FC_2 = metaOutputFDR_OrderbyPval_Log2FC_2,
              metaOutputFDR_OrderbyPval_Log2FC_1 = metaOutputFDR_OrderbyPval_Log2FC_1,
              metaOutputFDR_OrderbyPval_Log2FC_0.5 = metaOutputFDR_OrderbyPval_Log2FC_0.5))
  
  # Remove temporary objects
  rm(tempPvalAdjMeta, metaPvalAdj, TempDF, TempDF2)
}
```


```{r run_FDR, cache = TRUE}
# Function use 

# Meta-analysis with 0 NA 
metaOutputFDR_all_0NA <- FalseDiscoveryCorrection(0,
                                                 metaOutput_0NA,
                                                 HOM_MouseVsRat,
                                                 MetaAnalysis_Annotation_0NA)

# Because all 6 datasets are from mouse models, we would focus more on mouse
# gene symbols

# Separate the FDR outputs into individual objects 

# Meta-analysis with FDR output only 
metaOutputFDR_0NA <- metaOutputFDR_all_0NA[[1]]

# Meta-analysis with FDR output with annotations
metaOutputFDR_Annotated_0NA <- metaOutputFDR_all_0NA[[2]]

# Meta-analysis with FDR output ordered by p-values 
metaOutputFDR_OrderByPval_0NA <- metaOutputFDR_all_0NA[[3]]

# Meta-analysis with FDR output ordered by p-values filtered by Log2FC at 2
metaOutputFDR_OrderbyPval_Log2FC_2_0NA <- metaOutputFDR_all_0NA[[4]]

# Meta-analysis with FDR output ordered by p-values filtered by Log2FC at 1
metaOutputFDR_OrderbyPval_Log2FC_1_0NA <- metaOutputFDR_all_0NA[[5]]

# Meta-analysis with FDR output ordered by p-values filtered by Log2FC at 0.5
metaOutputFDR_OrderbyPval_Log2FC_0.5_0NA <- metaOutputFDR_all_0NA[[6]]
```


### 14) Forest plots for statistically significant genes 

```{r check_range}
# Check the range of Log2FC values
hist(metaOutputFDR_0NA[, 1], breaks = 40) 
```


```{r func_forest_plot}
# Create a function to generate forest plot
MakeForestPlots <- function(metaOutputFDR_annotated, 
                            GeneSymbol, 
                            species, 
                            MetaAnalysis_FoldChanges_ForMeta,
                            MetaAnalysis_SV_ForMeta){
  
  # "gene_row" object always return a dataframe with a lot of NA row so only row 
  # with the least NA values across columns is extracted for "gene_row"
  if (species == "Mouse"){
    gene_row <- metaOutputFDR_annotated[metaOutputFDR_annotated$Mouse_Symbol == GeneSymbol, ]
    gene_row <- gene_row[which.max(rowSums(!is.na(gene_row))), ]
  } else if (species == "Rat"){
    gene_row <- metaOutputFDR_annotated[metaOutputFDR_annotated$Rat_Symbol == GeneSymbol, ]
    gene_row <- gene_row[which.max(rowSums(!is.na(gene_row))), ]
  } else {
    stop("Please use either 'Mouse' or 'Rat' to indicate whether you are using annotation for mouse or rat genes")
  }
  
  # Check if the gene exists
  if (nrow(gene_row) == 0){
    stop(paste("No gene found for symbol:", GeneSymbol))
  }
  
  # Extract gene symbols for specific species
  MouseGeneSymbol <- gene_row$Mouse_Symbol
  RatGeneSymbol <- gene_row$Rat_Symbol
  
  # Extract Log2FC and SV 
  if (species == "Mouse"){
    fc <- as.numeric(MetaAnalysis_FoldChanges_ForMeta[MetaAnalysis_FoldChanges_ForMeta$Mouse_EntrezGene.ID == gene_row$Mouse_EntrezGene.ID, -c(1:3)])
    sv <- as.numeric(MetaAnalysis_SV_ForMeta[MetaAnalysis_FoldChanges_ForMeta$Mouse_EntrezGene.ID == gene_row$Mouse_EntrezGene.ID, -c(1:3)])
  } else if (species == "Rat"){
    fc <- as.numeric(MetaAnalysis_FoldChanges_ForMeta[MetaAnalysis_FoldChanges_ForMeta$Rat_EntrezGene.ID == gene_row$Rat_EntrezGene.ID, -c(1:3)])
    sv <- as.numeric(MetaAnalysis_SV_ForMeta[MetaAnalysis_FoldChanges_ForMeta$Rat_EntrezGene.ID == gene_row$Rat_EntrezGene.ID, -c(1:3)])
  }
  
  # Create the filename for the output plot
  filename <- paste("ForestPlot_Mouse_", GeneSymbol, "_Rat_", RatGeneSymbol, ".png", sep = "")
  
  # Open a PNG device with specified resolution
  png(filename, height = 5, width = 8, units = "in", res = 300)
  
  # Create the forest plot
  forest.rma(rma(fc, sv), 
             slab = colnames(MetaAnalysis_FoldChanges_ForMeta)[-c(1:3)], 
             xlim = c(-10, 10), 
             cex = 0.75)
  
  # Add labels to the plot
  mtext(paste("Mouse:", GeneSymbol, "_Rat:", RatGeneSymbol, sep = ""), 
        line = -1.5, 
        cex = 1.5)
  
  # Close the PNG device
  dev.off()
}
```


```{r run_forest_plot_1, cache = TRUE}
# Function use 

# Top genes ordered by p-values

# Ppp2r5a
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Ppp2r5a",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Cdhr1
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Cdhr1",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Sema5b
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Sema5b",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Sema7a
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Sema7a",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Thop1
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Thop1",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Cpd
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Cpd",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Col6a1
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Col6a1",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Col16a1
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Col16a1",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Spcs2
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Spcs2",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)
```


```{r run_forest_plot_2, cache = TRUE}
# Function use

# Top genes ordered by p-values with |Log2FC|  1 

# Gbp3
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Gbp3",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Ifit1
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Ifit1",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Usp18
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Usp18",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# B2m
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "B2m",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Gbp2
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Gbp2",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Oasl2
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Oasl2",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Bst2
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Bst2",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Bst2
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Bst2",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Iigp1
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Iigp1",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Irgm1
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Irgm1",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Stat1 
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Stat1",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Gbp7
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Gbp7",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Trim30a
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Trim30a",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# H2-K1 
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "H2-K1",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Ifitm3 
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Ifitm3",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Isg15
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Isg15",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Cd52
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Cd52",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Plac8
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Plac8",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Ifi44
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Ifi44",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Psmb9
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Psmb9",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)

# Psmb9
MakeForestPlots(metaOutputFDR_Annotated_0NA,
                "Cxcl10",
                "Mouse",
                MetaAnalysis_FoldChanges_ForMeta_0NA,
                MetaAnalysis_SV_ForMeta_0NA)
```


**Interpretation of Forest Plots**

**1. Study Labels (Left Side)**

- The labels on the left side of the plot indicate the individual contrasts included
in the meta-analysis.

**2. Effect Sizes and Confidence Intervals (Right side)**

- Each horizontal line represents the effect size (Log2FC) for a particular contrast
along with its confidence interval. The squares represent the point of estimate of 
the effect size for each contrast. The horizontal lines extending from the squares
are the confidence intervals for the effect size.

- The size of the squares represent the weight of each contrast in the meta-analysis,
with larger square indicating more weight.


**3. Overall Effect (Bottom)**

- The diamond shape at the bottom of the plot represents the overall effect size 
calculated from the meta-analysis (random-effects model).

- The width of the diamond represents the confidence interval for the overall effect
size.

**4. X-axis (Observed Outcome)**

- The x-axis shows the scale/range for the effect sizes (Log2FC).

- The vertical dash line at 0 indicate no effect. Effect sizes to the left of this 
line suggest a decrease, while those to the right suggest an increase.


### 15) Retrieval the function of statistically significant gene  

```{r func_extract_gene_function}
# Create a function to get gene function from NCBI using Entrez Gene ID
GetGeneFunctionByID <- function(NumberOfNAs, Log2FCThreshold, EntrezGeneList) {
  
  # Create an empty list to store the result 
  gene_info_list <- list()
  
  # Loop through each Entrez Gene ID 
  for(i in EntrezGeneList){
    
    # Print the message indicating which gene is being processed 
    print(paste("Processing Entrez Gene ID:", i, sep = ""))
    
    # Retrieve the gene summary using the Entrez Gene ID
    gene_summary <- tryCatch({
      entrez_summary(db = "gene", id = i)
    }, 
    
    # In case of error, print a warning and return NULL 
    error = function(e){
      warning(paste("Error in retrieving data for Entrez Gene ID:", i, sep = "", e$message))
      return(NULL)
    })
    
    # Check if the gene summary was successfully retrieved  
    if(!is.null(gene_summary)){
      # If the gene summaray is not NULL, extract relevant info
      gene_info_list[[i]] <- list(
        # ID
        Entrez_ID = gene_summary$uid,
        # Gene symbol
        Gene_symbol = gene_summary$name,
        # Full name of gene
        Gene_description = gene_summary$description,
        # Location on chromosome
        Chromosome = gene_summary$chromosome,
        # Detailed location
        Map_location = gene_summary$maplocation,
        # Scientific name of model
        Model_scientific_name = gene_summary$organism$scientificname,
        # Common name of model
        Model_common_name = gene_summary$organism$commonname,
        # Function of the gene
        Gene_function = gene_summary$summary
      )
    } else {
      # If the gene summary is NULL, return NA for all columns
      gene_info_list[[i]] <- list(
        Entrez_ID = i,
        Gene_symbol = NA,
        Gene_description = NA,
        Chromosome = NA,
        Map_location = NA,
        Model_scientific_name = NA,
        Model_common_name = NA,
        Gene_function = NA
      )
    }
    # Introduce a delay of 0.5 seconds between request to avoid hitting API rate limit
    Sys.sleep(0.5)
  }
  
  # Convert the final list into a dataframe
  gene_info_df <- do.call(rbind, lapply(gene_info_list, as.data.frame))
  rownames(gene_info_df) <- NULL
  
  # Export the dataframe of gene function into working directory
  write.csv(gene_info_df, 
            paste("Gene_function_Log2FC_", Log2FCThreshold, "_", NumberOfNAs, "NA.csv", sep = ""))
  
  # Return the dataframe of gene function
  return(gene_info_df)
}
```


```{r run_extract_gene_function, cache = TRUE}
# Extract gene entrez ID for genes with FDR < 0.05 & |Log2FC|  1
EntrezGeneList_OrderbyPval_Log2FC_1_0NA <- metaOutputFDR_OrderbyPval_Log2FC_1_0NA %>%
  filter(FDR < 0.05) %>%
  pull(Mouse_EntrezGene.ID)

# Extract gene entrez ID for genes with FDR < 0.05 & |Log2FC|  2
EntrezGeneList_OrderbyPval_Log2FC_2_0NA <- metaOutputFDR_OrderbyPval_Log2FC_2_0NA %>%
  filter(FDR < 0.05) %>%
  pull(Mouse_EntrezGene.ID)

# Function use
GeneFunction_Log2FC_1_0NA <- GetGeneFunctionByID(0,
                                                 1,
                                                 EntrezGeneList_OrderbyPval_Log2FC_1_0NA)

GeneFunction_Log2FC_2_0NA <- GetGeneFunctionByID(0,
                                                 2,
                                                 EntrezGeneList_OrderbyPval_Log2FC_2_0NA)

# Check the structure of the output
str(GeneFunction_Log2FC_1_0NA)
str(GeneFunction_Log2FC_2_0NA)
```


### 16) Enrichment analysis (EA) with KEGG/GO/Reactome databases

The difference between Enrichment Analysis, GSEA, and fGSEA:

**1. Enrichment Analysis (EA)**

- *Definition:* Enrichment analysis refers to a collection of methods used to determine 
whether predefined gene sets (such as biological pathways or functional categories) 
are overrepresented in a list of genes of interest, often derived from differential 
expression studies.

- *Goal:* The goal is to identify if specific gene sets are significantly enriched 
in the gene list compared to a background set of genes. This can highlight biological 
processes or pathways that are impacted in the condition of interest.

- *Method:* Enrichment analysis typically involves comparing the gene list to a 
background gene set using various statistical tests. The most common methods include 
Fisher's exact test, hypergeometric test,... The analysis can be performed on a 
gene set level without requiring a pre-ranked list.

- *Flexibility:* This approach can be used with different types of gene set databases 
(e.g., KEGG, GO, Reactome). The choice of the background gene set can affect the 
results, and the method may not be sensitive to the ranking of genes.

**2. Gene Set Enrichment Analysis (GSEA)**

- *Definition:* GSEA is a computational method used to determine whether a predefined 
set of genes shows statistically significant differences between two biological 
states or conditions based on a ranked list of genes.

- *Goal:* The goal of GSEA is to identify whether specific gene sets are overrepresented 
or enriched in a ranked list of genes, which is derived from differential expression 
analysis. GSEA is particularly useful for analyzing genome-wide expression profiles 
to determine whether gene sets are preferentially located at the top or bottom of 
the ranked list.

- *Method:* 

  - **Step 1: Calculation of Enrichment Score (ES)** 
  
  GSEA calculates an enrichment score that reflects the degree to which a gene set 
  is overrepresented at the extremes (top or bottom) of the ranked list. The score 
  is derived from a running-sum statistic, which increases when encountering genes 
  in the set and decreases otherwise, with the magnitude of the increment based 
  on the genes correlation with the phenotype.
  
  - **Step 2: Estimation of Significance Level of ES** 
  
  Significance is estimated using permutation-based tests, where phenotype labels 
  are permuted to create a null distribution for the ES. The empirical p-value is 
  calculated based on this distribution.
  
  - **Step 3: Adjustment for Multiple Hypothesis Testing** 
  The method normalizes the ES for each gene set to yield a normalized enrichment 
  score (NES). The false discovery rate (FDR) is calculated to control the proportion 
  of false positives.
  
- *Sensitivity:* GSEA is sensitive to the choice of background gene set and requires 
careful selection to avoid misleading results. It uses the entire ranked list of 
genes and does not rely on arbitrary cut-offs due to its rank-based. However, this 
sometimes results in gene sets/pathways that end up showing the strongest enrichment
are driven by genes that would not necessarily meet the traditional FDR cut-off. 
These genes are normally referred to as **"leading genes"**.

- *Input:* GSEA requires a full, pre-ranked list of genes based on metrics such as 
p-values or Log2FC.

**3.Fast Gene Set Enrichment Analysis (fGSEA)**

- *Definition:* fGSEA is an adaptation of GSEA designed to provide faster and 
computationally efficient enrichment analysis using approximation techniques.

- *Goal:* The goal of fGSEA is to maintain the accuracy of GSEA while significantly 
reducing the computation time required for large datasets.

- *Method:* fGSEA employs fast approximation methods for calculating enrichment scores,
which simplifies the process 

- *Flexibility:* fGSEA is more robust to variations in the background gene set due to
its approximation techniques but can still benefit from a well-chosen background for 
accurate interpretation. The output of fGSEA are leading genes, which is similar to GSEA.

- *Input:* fGSEA requires a full, pre-ranked list of genes based on metrics such as 
p-values or Log2FC.


| Feature                | Enrichment Analysis       | GSEA                 | fGSEA                |
|------------------------|----------------------------|----------------------|----------------------|
| Requires ranked gene list | No                         | Yes                  | Yes                  |
| Statistical test       | Various (e.g., Fisher's exact, hypergeometric) | Permutation-based     | Approximation-based   |
| Computational efficiency | Fast                       | Slow                 | Fast                 |
| Sensitivity to background | Less sensitive            | Sensitive            | Less sensitive        |


Ref for Overview of GSEA: 
https://www.pnas.org/doi/full/10.1073/pnas.0506580102

Ref for enrichment analysis with GO database using `clusterProfiler`: https://yulab-smu.top/biomedical-knowledge-mining-book/clusterprofiler-go.html

Ref for enrichment analysis with KEGG database using `clusterProfiler`:
https://yulab-smu.top/biomedical-knowledge-mining-book/clusterprofiler-kegg.html

Ref for enrichment analysis with KEGG database using `clusterProfiler`:
https://yulab-smu.top/biomedical-knowledge-mining-book/reactomepa.html


```{r func_EA_KEGG_GO_Reactome}
# Create a function to perform EA on common databases, including KEGG, GO, and 
# Reactome
EAPerform_KEGG_GO_Reactome <- function(EntrezGeneList,
                                       metaOuput,
                                       pvalueCutOff,
                                       qvalueCutOff){
  
  # Perform EA with KEGG database 
  KEGG_EA_result <- enrichKEGG(gene = EntrezGeneList,
                               # Organism code for Mus musculus
                               organism = "mmu",
                               # Address the background gene set (output of meta-analysis)
                               universe = metaOuput,
                               # p-value cut off
                               pvalueCutoff = pvalueCutOff,
                               # Choose the method for FDR of GSEA (Benjamini-Hochberg)
                               pAdjustMethod = "BH",
                               # FDR cut off
                               qvalueCutoff = qvalueCutOff)
  
  # Perform EA with GO database 
  GO_EA_result <- enrichGO(gene = EntrezGeneList,
                           # Select database for Mus musculus
                           OrgDb = org.Mm.eg.db,
                           # Ontology for biological process
                           # Other ontologies include "MF" for Molecular Function
                           # and "CC" for Cellular Component 
                           ont = "BP", 
                           # Address the background gene set (output of meta-analysis)
                           universe = metaOuput,
                           # p-value cut off
                           pvalueCutoff = pvalueCutOff,
                           # Choose the method for FDR of GSEA (Benjamini-Hochberg)
                           pAdjustMethod = "BH",
                           # FDR cut off
                           qvalueCutoff = qvalueCutOff)
  
  # Perform EA with Reactome database 
  Reactome_EA_result <- enrichPathway(gene = EntrezGeneList,
                                      # Organism code for Mus musculus
                                      organism = "mouse",
                                      # Address the background gene set (output of meta-analysis)
                                      universe = metaOuput,
                                      # p-value cut off
                                      pvalueCutoff = pvalueCutOff,
                                      # Choose the method for FDR of GSEA (Benjamini-Hochberg)
                                      pAdjustMethod = "BH",
                                      # FDR cut off
                                      qvalueCutoff = qvalueCutOff)
  
  # Return the list of results
  return(list(KEGG = KEGG_EA_result, 
              GO = GO_EA_result,
              Reactome = Reactome_EA_result))
}
```


```{r run_EA_KEGG_GO_Reactome, cache = TRUE}
# Function use
EntrezGeneList_metaOutputFDR_0NA <- as.character(metaOutputFDR_Annotated_0NA$Mouse_EntrezGene.ID)

EA_Log2FC_1_0NA <- EAPerform_KEGG_GO_Reactome(EntrezGeneList_OrderbyPval_Log2FC_1_0NA,
                                              EntrezGeneList_metaOutputFDR_0NA,
                                              0.05,
                                              0.05)

EA_Log2FC_2_0NA <- EAPerform_KEGG_GO_Reactome(EntrezGeneList_OrderbyPval_Log2FC_2_0NA,
                                              EntrezGeneList_metaOutputFDR_0NA,
                                              0.05,
                                              0.05)

```


```{r plot_GSEA_KEGG, cache = TRUE}
# Visualize the EA results with KEGG database 

# Top 10 pathways using barplot presentation for genes with FDR < 0.05 and with |Log2FC|  1

# png("EA_Log2FC_1_0NA_KEGG.png", 8, 5, "in", res = 300)
barplot(EA_Log2FC_1_0NA$KEGG, showCategory = 10, font.size = 7)
# dev.off()


# Top 10 pathways using barplot presentation for genes with FDR < 0.05 and with |Log2FC|  2

# png("EA_Log2FC_2_0NA_KEGG.png", 8, 5, "in", res = 300)
barplot(EA_Log2FC_2_0NA$KEGG, showCategory = 10, font.size = 7)
# dev.off()


# Visualize individual enriched pathways

# Filter genes with FDR < 0.05 in genes of meta-analysis output with |Log2FC|  1
KEGG_metaOutputFDR_Log2FC_1_0NA_FDR_0.05 <- metaOutputFDR_OrderbyPval_Log2FC_1_0NA %>%
  filter(FDR < 0.05)

# Prepare the named vector
# Names = Mouse_EntrezGene.ID | Values  = Log2FC estimate 
KEGGgenedata_metaOutputFDR_Log2FC_1_0NA <- setNames(
  KEGG_metaOutputFDR_Log2FC_1_0NA_FDR_0.05$Log2FC_estimate,
  KEGG_metaOutputFDR_Log2FC_1_0NA_FDR_0.05$Mouse_EntrezGene.ID
)

# Filter genes with FDR < 0.05 in genes of meta-analysis output with |Log2FC|  2
KEGG_metaOutputFDR_Log2FC_2_0NA_FDR_0.05 <- metaOutputFDR_OrderbyPval_Log2FC_2_0NA %>%
  filter(FDR < 0.05)

# Prepare the named vector
# Names = Mouse_EntrezGene.ID | Values  = Log2FC estimate 
KEGGgenedata_metaOutputFDR_Log2FC_2_0NA <- setNames(
  KEGG_metaOutputFDR_Log2FC_2_0NA_FDR_0.05$Log2FC_estimate,
  KEGG_metaOutputFDR_Log2FC_2_0NA_FDR_0.05$Mouse_EntrezGene.ID
)

# Generate pathway view for "mmu05164" with genes of FDR < 0.05 and |Log2FC|  1
mmu05164 <- pathview(gene.data = KEGGgenedata_metaOutputFDR_Log2FC_1_0NA,
                     pathway.id = "mmu05164",
                     species = "mmu",
                     limit = list(gene = c(min(KEGGgenedata_metaOutputFDR_Log2FC_1_0NA), 
                                           max(KEGGgenedata_metaOutputFDR_Log2FC_1_0NA)), 
                                  cpd = 1))

# Generate pathway view for "mmu04621" with genes of FDR < 0.05 and |Log2FC|  1
mmu04621 <- pathview(gene.data = KEGGgenedata_metaOutputFDR_Log2FC_1_0NA,
                     pathway.id = "mmu04621",
                     species = "mmu",
                     limit = list(gene = c(min(KEGGgenedata_metaOutputFDR_Log2FC_1_0NA), 
                                           max(KEGGgenedata_metaOutputFDR_Log2FC_1_0NA)), 
                                  cpd = 1))

# Generate pathway view for "mmu04061" with genes of FDR < 0.05 and |Log2FC|  1
mmu04061 <- pathview(gene.data = KEGGgenedata_metaOutputFDR_Log2FC_1_0NA,
                     pathway.id = "mmu04061",
                     species = "mmu",
                     limit = list(gene = c(min(KEGGgenedata_metaOutputFDR_Log2FC_1_0NA), 
                                           max(KEGGgenedata_metaOutputFDR_Log2FC_1_0NA)), 
                                  cpd = 1))
```


```{r plot_GSEA_GO, cache = TRUE}
# Visualize the EA results with GO database 

# Visualize the results with directed acyclic graph

# png("EA_Log2FC_1_0NA_GO_Network.png", 8, 5, "in", res = 300)
goplot(EA_Log2FC_1_0NA$GO)
# dev.off()

# png("EA_Log2FC_2_0NA_GO_Network.png", 8, 5, "in", res = 300)
goplot(EA_Log2FC_2_0NA$GO)
# dev.off()

# Top 10 pathways using barplot presentation for genes with FDR < 0.05 and with |Log2FC|  1

# png("EA_Log2FC_1_0NA_GO.png", 8, 5, "in", res = 300)
barplot(EA_Log2FC_1_0NA$GO, showCategory = 10, font.size = 7)
# dev.off()

# Top 10 pathways using barplot presentation for genes with FDR < 0.05 and with |Log2FC|  2

# png("EA_Log2FC_2_0NA_GO.png", 8, 5, "in", res = 300)
barplot(EA_Log2FC_2_0NA$GO, showCategory = 10, font.size = 7)
# dev.off()
```


```{r plot_GSEA_Reactome, cache = TRUE}
# Visualize the GSEA results with Reactome database 

# Top 10 pathways using barplot presentation for genes with FDR < 0.05 and with |Log2FC|  1

# png("EA_Log2FC_1_0NA_Reactome.png", 8, 5, "in", res = 300)
barplot(EA_Log2FC_1_0NA$Reactome, showCategory = 10, font.size = 7)
# dev.off()

# Top 10 pathways using barplot presentation for genes with FDR < 0.05 and with |Log2FC|  2

# png("EA_Log2FC_2_0NA_Reactome.png", 8, 5, "in", res = 300)
barplot(EA_Log2FC_2_0NA$Reactome, showCategory = 10, font.size = 7)
# dev.off()
```


```{r export_GSEA, cache = TRUE}
# Transform the matched pathways results into dataframes and export into the working
# directory
EA_Log2FC_1_0NA_KEGG <- as.data.frame(EA_Log2FC_1_0NA$KEGG)
row.names(EA_Log2FC_1_0NA_KEGG) <- NULL
write.csv(EA_Log2FC_1_0NA_KEGG, "EA_Log2FC_1_0NA_KEGG.csv")

EA_Log2FC_2_0NA_KEGG <- as.data.frame(EA_Log2FC_2_0NA$KEGG)
row.names(EA_Log2FC_2_0NA_KEGG) <- NULL
write.csv(EA_Log2FC_2_0NA_KEGG, "EA_Log2FC_2_0NA_KEGG.csv")

EA_Log2FC_1_0NA_GO <- as.data.frame(EA_Log2FC_1_0NA$GO)
row.names(EA_Log2FC_1_0NA_GO) <- NULL
write.csv(EA_Log2FC_1_0NA_GO, "EA_Log2FC_1_0NA_GO.csv")

EA_Log2FC_2_0NA_GO <- as.data.frame(EA_Log2FC_2_0NA$GO)
row.names(EA_Log2FC_2_0NA_GO) <- NULL
write.csv(EA_Log2FC_2_0NA_GO, "EA_Log2FC_2_0NA_GO.csv")

EA_Log2FC_1_0NA_Reactome <- as.data.frame(EA_Log2FC_1_0NA$Reactome)
row.names(EA_Log2FC_1_0NA_Reactome) <- NULL
write.csv(EA_Log2FC_1_0NA_Reactome, "EA_Log2FC_1_0NA_Reactome.csv")

EA_Log2FC_2_0NA_Reactome <- as.data.frame(EA_Log2FC_2_0NA$Reactome)
row.names(EA_Log2FC_2_0NA_Reactome) <- NULL
write.csv(EA_Log2FC_2_0NA_Reactome, "EA_Log2FC_2_0NA_Reactome.csv")
```


### 17) Fast Gene Set Enrichment Analysis (fGSEA) with Brain.GMT database [Need to fix]

The Brain.GMT database, developed by Hagenauer et al. (2024), is designed to improve 
the interpretation of brain-derived differential expression results, especially 
in studies focused on neuropsychiatric disorders. The Brain.GMT can be used within 
common pipelines (GSEA, limma, edgeR) to interpret results from 3 species of rat, 
mouse, human. The database includes 918 gene sets derived from various sources, 
each curated to be relevant to brain functions, brain cell types, co-expression networks, 
and regional gene expression signatures.

Gene sets included in the Brain.GMT:

**1. MSigDB Gene SetS**

- Curated Gene Sets: 158 gene sets related to the nervous system.

- Cell Type Signature Gene Sets: 211 gene sets related to the nervous system and blood.

**2. BrainInABlender**

- 39 gene sets related to cell type-enriched expression, particularly in the cortex.

**3. DropViz**

- 13 gene sets focused on hippocampal expression, and 12 gene sets for the nucleus accumbens.

**4. HippoSeq**

- 14 gene sets related to regional enriched expression in the hippocampus.

**5. Coexpression Analyses**

- 55 gene sets derived from coexpression networks in the hippocampus.

**6. Gene Weaver**

- 33 gene sets for the hippocampus and 6 gene sets for the nucleus accumbens related 
to stress, environmental enrichment, affective behavior, and mood disorder.

**7. Gemma**

- 29 gene sets derived from reanalysis pipelines focusing on stress, environmental 
enrichment, affective behavior, and mood disorder in the nucleus accumbens.

Ref for Brain.GMT: https://doi.org/10.1016/j.mex.2024.102788

Ref for orginal GSEA: https://doi.org/10.1073/pnas.0506580102

Although the Brain.GMT focuses on brain-related genes, the impact of viral infection
might involve specific pathways or immune responses that are not well-represented
in this database.

Use all of the meta-analysis output and ordered it by Log2FC values (pre-ranked lists)

```{r run_GSEA_BrainGMT, cache = TRUE}
# fGSEA uses the entirety of the gene list but need to pre-ranked with either p-values
# or Log2FC. For Brain.GMT, we use gene list pre-ranked by Log2FC. 

# Create a named vector from meta-analysis output
# Names = Mouse gene symbol | Values = Log2FC estimate
BrainGMTgenedata_metaOutputFDR_0NA <- setNames(
  metaOutputFDR_Annotated_0NA$Log2FC_estimate,
  metaOutputFDR_Annotated_0NA$Mouse_Symbol
)

# Remove genes with NA or duplicated names
BrainGMTgenedata_metaOutputFDR_0NA_cleaned <- BrainGMTgenedata_metaOutputFDR_0NA %>%
  # Convert to dataframe for easier manipulation
  enframe(name = "gene_name", value = "Log2FC_estimate") %>%
  # Remove rows with NA names
  filter(!is.na(gene_name)) %>%
  # Remove rows with finite Log2FC values 
  filter(is.finite(Log2FC_estimate)) %>%
  # Remove duplicated names, keeping the first instance
  distinct(gene_name, .keep_all = TRUE) %>%
  # Convert back to named vector
  deframe()

# Order the vector by Log2FC in ascending order
BrainGMTgenedata_metaOutputFDR_OrderedbyLog2FC_0NA <- BrainGMTgenedata_metaOutputFDR_0NA_cleaned[order(BrainGMTgenedata_metaOutputFDR_0NA_cleaned)]

# Import the Brain.GMT for the specific species of interest
# Ignore the warning about incomplete line 
BrainGMT_Mouse <- gmtPathways("BrainGMTv2_wGO_MouseOrthologs.gmt.txt")

# Perform fast fGSEA with Brain.GMT
fGSEA_0NA_BrainGMT <- fgseaSimple(BrainGMT_Mouse, 
                                  BrainGMTgenedata_metaOutputFDR_OrderedbyLog2FC_0NA,
                                  # Number of permutations for the GSEA
                                  nperm = 10000,
                                  # Minimum size of gene sets to consider
                                  minSize = 10,
                                  # Maximum size of gene sets to consider 
                                  maxSize = 1000)

# Converts the list of leading edge genes (genes contributing to enrichment) in 
# the fGSEA results to a comma-separated string
fGSEA_0NA_BrainGMT$leadingEdge <- vapply(fGSEA_0NA_BrainGMT$leadingEdge, 
                                         paste, 
                                         collapse= ",", 
                                         character(1L))

# Order the fGSEA results based on adjusted p-values 
fGSEA_0NA_BrainGMT <- fGSEA_0NA_BrainGMT %>%
  arrange(padj)

# Filter the fGSEA results for FDR < 0.01 and count the number of leading edges 
# in each pathways
fGSEA_0NA_BrainGMT_FDR_filtered <- fGSEA_0NA_BrainGMT %>%
  filter(padj < 0.01) %>%
  mutate(Num_leadingEdge = sapply(strsplit(leadingEdge, ","), length))

# Export the matched pathways into the working directory
write.csv(fGSEA_0NA_BrainGMT, "fGSEA_0NA_BrainGMT.csv")
write.csv(fGSEA_0NA_BrainGMT_FDR_filtered, "fGSEA_0NA_BrainGMT_FDR_filtered.csv")
```


**Interpretation of fGSEA**

**1. padj (Adjusted p-value)**

- *Definition:* This is the p-value adjusted for multiple comparisons for the False 
Discovery Rate (FDR) using the family-wise error rate method. It controls for the 
proportion of false positives among the significant results. 

- *Explanation:* A low padj value (e.g., < 0.05) indicates that the enrichment of 
a gene set is statistically significant after correction for multiple testing, 
reducing the likelihood of false positives.

**2. ES (Enrichment Score)**

- *Definition:* The Enrichment Score (ES) represents the degree to which a gene set 
is overrepresented at the top or bottom of a ranked list of genes. It is calculated 
by walking down the list of pre-ranked genes and increasing a running-sum statistic 
when a gene in the gene set is encountered and decreasing it when a gene not in 
the gene set is encountered.

- *Explanation:*
  - A positive ES suggests that the gene set is enriched among genes that are upregulated 
  (i.e., genes at the top of the ranked list).
  - A negative ES indicates that the gene set is enriched among genes that are 
  downregulated (i.e., genes at the bottom of the ranked list).

**3. NES (Normalized Enrichment Score)**

- *Definition:* The Normalized Enrichment Score (NES) is the enrichment score (ES) 
that has been normalized across all gene sets to account for differences in gene 
set size. It allows for comparison between gene sets of different sizes.

- *Explanation:* 
  - NES adjusts the ES so that it can be compared across gene sets of different sizes:
    - Positive NES: Indicates the gene set is upregulated in your data.
    - Negative NES: Indicates the gene set is downregulated in your data.
    
**4. leadingEdge**

- *Definition:* The leading-edge subset is the subset of genes in the gene set 
that contribute most to the enrichment score. These are the genes that appear 
before the peak enrichment score is reached and thus drive the observed enrichment.

- *Explanation:* This variable contains the "core" genes responsible for the enrichment 
signal. Understanding which genes are in the leading edge can provide insights into 
which genes are most responsible for the phenotype of interest.

**5. nMoreExtreme**

- *Definition:* nMoreExtreme represents the number of permutations where the observed 
ES was more extreme (either higher or lower) than the ES obtained from random permutations 
of the gene set.

- *Explanation:* This variable helps estimate the empirical p-value for the observed ES. 
A lower nMoreExtreme value indicates that few random permutations achieved an ES as 
extreme as the observed one, suggesting that the observed enrichment is unlikely 
to be due to chance.

**6. Size**

- *Definition:* Size indicates the number of genes in the gene set that overlap 
with the pre-ranked list of genes used in the enrichment analysis.

- *Explanation:* This is the effective size of the gene set in the context of the 
analysis. Larger gene sets might have more opportunities to show enrichment, but 
smaller gene sets can also provide strong signals if their genes are strongly associated 
with the phenotype of interest.


